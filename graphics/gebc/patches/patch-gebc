diff -x Makefile.in -x autom4te.cache -x configure -x aclocal.m4 -urN gebc-1.07/ChangeLog gebc-1.07-mike/ChangeLog
--- gebc-1.07/ChangeLog	2008-03-01 04:47:22.000000000 +0900
+++ gebc-1.07-mike/ChangeLog	2011-01-29 16:38:04.874067530 +0800
@@ -0,0 +1,88 @@
+
+Jan 2011  mnix@wanm.com.au
+
+*	Added TargetWindow - view of target as seen from shooter.
+
+*	Added a perspective checkbox to the target window. This switches
+	between path as seen by shooter (on) and path relative to line of
+	sight (off).  For example, a bullet 1/2 way to the target will
+	line up with a point twice as far above line of sight in the target
+	as it actually is. ie if the bullet is 1" above line of sight at 50
+	yds, it will be in line with a point 2" above line of sight on a
+	target at 100 yds. The line appears to move on the target because as
+	you move the target back (say to 200 yds) the bullet at 50 yds and
+	1" high will line up with a point 4" high on the target at 200 yds.
+
+*	If a file name is given on the command line it is loaded at startup.
+	No checking is done on the file name - if it does not exist,
+	bad things may happen.
+
+*	Added various target types including common NRA and ISSF targets
+
+*	Added a "variance" ring around the impact point. This is 1 MOA plus
+	a bit on the sides as alowance for spin drift (it's added to both
+	sides and left to the viewer to decide on whether to allow for left
+	or right twist. The amount is so small it doesn't matter much
+	anyway (we allow a generic 0.1 MOA per 100 yards beyond 100 yards)
+
+Nov 2010  mnix#wanm.com.au
+
+*	Added a drop down box to the Plot Window to select scope guides.
+
+*	Changed the calculations for the scope guides to draw them more
+	accurately.
+
+*	Get Zero to float in the path plot
+
+*	Clip the scope guides
+
+*	Added an option for guides every 1 degree
+
+Oct 2010  mnix@wanm.com.au
+
+*	Added scope guides to the path plot as a ready reference to how the
+	trajectory compares to the field of view of the scope, in particular to
+	one and 5 MIL marks on a MIL-DOT reticle. Included code for MOA
+	as well, but commented it out pending GUI button to select
+	MIL/MOA/NONE
+
+*	Modified InputWindow and PlotWindow to handle plotting memory 3
+
+*	Consolidated a lot of code in PlotWindow into 3 new functions.
+
+*	modified InputWindow::cb_Solve() to treat zero ranges < 2 yards as a
+	zeroangle and report the zeroangle used in the output window.
+	This allows plotting the paths of different loads shot from the one
+	barrel and scope alignment (eg for a two different loads in a .308
+	without adjusting the scope, what is the elevation adjustment for
+	each load?)  Useful for hunters who might select different loads for
+	different targets, but do not want to mess with their zero.
+
+*	Allowed for larger y_range in plots.
+
+*	Reduced the minimum range in the PlotWindow to 50 yds (default still
+	200).  Useful for low power (ie .22) shooters.
+
+*	Added Drop (MIL), Windage (MIL) and Target Size (MIL) columns to the
+	RangeWindow (not all export formats have been updated yet).
+	All useful for users of MIL-DOT reticles.
+	Need to add a GUI box for entering the target size in inches - that
+	way you can enter the size in inches of whatever you intend to shoot,
+	then in the field measure your target in MIL in the scope, look that up
+	on the range table and instantly get bullet drop and windage in MIL,
+	no maths required.
+
+*	Added metric conversions of the summary data at the top of the range
+	table.
+
+*	Cleaned up SOME of the misuse of malloc/delete/free
+	delete calls the destructor then frees the memory. Calling free on
+	an object after deleting it is an error, so is calling delete after
+	calling the destructor!
+	Also mixing new/free and malloc/delete on the same object is bad.
+	Only use malloc with free, and only new with delete.
+
+*	Re-wrote the GenTable and Export* code in RangeWindow to be data-driven.
+	Adding a column, or modifying the layout of the load data is now
+	done in one place and automatically appears in ALL output formats.
+
diff -x Makefile.in -x autom4te.cache -x configure -x aclocal.m4 -urN gebc-1.07/GBCSolution.cpp gebc-1.07-mike/GBCSolution.cpp
--- gebc-1.07/GBCSolution.cpp	2008-03-01 04:47:22.000000000 +0900
+++ gebc-1.07-mike/GBCSolution.cpp	2011-01-22 22:24:42.296065542 +0800
@@ -32,6 +32,7 @@
 
 	if (this->sln != NULL) {
 		free(this->sln);
+		this->sln=NULL;
 	}	
 
 }
@@ -158,6 +159,14 @@
 	}
 	else return 0;
 }
+
+double GBCSolution::GetDrop(int yardage){
+	double size=sln[__BCOMP_MAXRANGE__*10+1];
+	if (yardage<size){
+		return sln[10*yardage+9];
+	}
+	else return 0;
+}
 
 double GBCSolution::GetEnergy(int k){
 	return (double)weight*GetVelocity(k)*GetVelocity(k)/450436;
diff -x Makefile.in -x autom4te.cache -x configure -x aclocal.m4 -urN gebc-1.07/GBCSolution.h gebc-1.07-mike/GBCSolution.h
--- gebc-1.07/GBCSolution.h	2008-03-01 04:47:22.000000000 +0900
+++ gebc-1.07-mike/GBCSolution.h	2011-01-22 22:23:42.961067473 +0800
@@ -58,6 +58,7 @@
 		double GetVelocity(int yardage);
 		double GetVx(int yardage);
 		double GetVy(int yardage);
+		double GetDrop(int yardage);
 		double GetEnergy(int yardage);
 		
 		int df;
diff -x Makefile.in -x autom4te.cache -x configure -x aclocal.m4 -urN gebc-1.07/GNU_Ballistics.cpp gebc-1.07-mike/GNU_Ballistics.cpp
--- gebc-1.07/GNU_Ballistics.cpp	2008-03-01 04:47:22.000000000 +0900
+++ gebc-1.07-mike/GNU_Ballistics.cpp	2011-01-28 07:36:44.813065702 +0800
@@ -2,8 +2,11 @@
 #include <FL/Fl_Window.H>
 #include "InputWindow.h"
 using namespace std;
-int main (){
+int main (int argc, char *argv[]){
    InputWindow win(400,500,"GNU Exterior Ballistics Computer");
+   if (argc==2) {
+      win.OpenFile(argv[1]);
+      }
    return Fl::run();
 }
 
diff -x Makefile.in -x autom4te.cache -x configure -x aclocal.m4 -urN gebc-1.07/InputWindow.cpp gebc-1.07-mike/InputWindow.cpp
--- gebc-1.07/InputWindow.cpp	2008-03-01 04:47:22.000000000 +0900
+++ gebc-1.07-mike/InputWindow.cpp	2011-01-27 13:23:16.830065235 +0800
@@ -1,6 +1,6 @@
 #include "lib/ballistics/ballistics.h"
 #include "InputWindow.h"
-
+#include "TargetWindow.h"
 
 InputWindow::InputWindow(int w, int h, const char* title):Fl_Window(w,h,title){
  
@@ -61,7 +61,7 @@
 	  inBC = new Fl_Float_Input(10,80,50,20," Drag Coefficient");
 	  inWeight=new Fl_Int_Input(10,105,50,20," Projectile Weight (grains)");
 	  inMV = new Fl_Int_Input(10,130,50,20," Initial Velocity (ft/s)");
-	  inZero = new Fl_Int_Input(10,155,50,20," Zero Range (yds)");
+	  inZero = new Fl_Float_Input(10,155,50,20," Zero Range (yds)");
 	  inSH = new Fl_Float_Input(10,180,50,20," Sight Height Over Bore (in)");
 	  inAngle = new Fl_Int_Input(10,205,50,20," Shooting Angle (deg)");
 	  inVwind = new Fl_Int_Input(10,230,50,20," Wind Velocity (mi/hr)");
@@ -146,6 +146,7 @@
 		  Fl_Menu_Item m_Analysis = {"&Analysis",0,0,0, FL_SUBMENU};
 			Fl_Menu_Item mc_RangeTable = {"&Range Table",0,(Fl_Callback*)cb_RangeTable,this};
 			Fl_Menu_Item mc_QuickPlot = {"Quick &Plot",0,(Fl_Callback*)cb_Plot, this};
+			Fl_Menu_Item mc_TargetPlot= {"&Target Plot",0,(Fl_Callback*)cb_Target, this};
 			Fl_Menu_Item mc_RangeCard = {"&Range Card",0,(Fl_Callback*)cb_Nothing};
 			Fl_Menu_Item mc_ClickChart = {"&Click Chart",0,(Fl_Callback*)cb_Nothing,this,FL_MENU_DIVIDER};
 			Fl_Menu_Item mc_MVA = {"&Advanced Analysis",0,(Fl_Callback*)cb_Nothing,this};
@@ -158,8 +159,8 @@
 	
 		  Fl_Menu_Item  m_Storage = {"&Solution Memory",0,0,0, FL_SUBMENU};
 			Fl_Menu_Item mc_Store1 = {"Store to Memory 1 ",0,(Fl_Callback*)cb_Store1,this};
-			Fl_Menu_Item mc_Store2 = {"Store to Memory 2 ",0,(Fl_Callback*)cb_Store2,this,FL_MENU_DIVIDER};
-			Fl_Menu_Item mc_Store3 = {"Store to Memory 3 ",0,(Fl_Callback*)cb_Store3,this};
+			Fl_Menu_Item mc_Store2 = {"Store to Memory 2 ",0,(Fl_Callback*)cb_Store2,this};
+			Fl_Menu_Item mc_Store3 = {"Store to Memory 3 ",0,(Fl_Callback*)cb_Store3,this,FL_MENU_DIVIDER};
 			Fl_Menu_Item mc_Store4 = {"Store to Memory 4 ",0,(Fl_Callback*)cb_Store4,this};
 			Fl_Menu_Item mc_Store5 = {"Store to Memory 5 ",0,(Fl_Callback*)cb_Store5,this};
 			Fl_Menu_Item mc_Store6 = {"Store to Memory 6 ",0,(Fl_Callback*)cb_Store6,this};
@@ -192,7 +193,7 @@
 
 
 	#define MANALYSIS 7
-	#define MSTORAGE 19
+	#define MSTORAGE 20
 	Fl_Menu_Item menuitems[] = {
 	  m_File, //0
 		mc_New,
@@ -204,18 +205,19 @@
 	  m_Analysis, //7
 		mc_RangeTable,
 		mc_QuickPlot,
+		mc_TargetPlot,
 		mc_RangeCard,
 		mc_ClickChart,
 	    mc_MVA, 
-		{0}, // 13
+		{0}, // 14
 	  m_Tools,
 	    mc_OptimizePBR,
 		mc_CalcBC,
 		mc_Options,
 		{0},
 	  m_Storage, 
-	    mc_Store1, //20
-		mc_Store2, //21
+	    mc_Store1, //21
+		mc_Store2, //22
 		mc_Store3,
 		mc_Store4,
 		mc_Store5,
@@ -242,7 +244,7 @@
 InputWindow::~InputWindow(){
 
 	// Free any memory we are using.
-	if (Solution!=NULL) {free(Solution);Solution=NULL;}
+	if (Solution!=NULL) { free(Solution); Solution=NULL;}
 	if (Smem1!=NULL) {  free(Smem1);  Smem1=NULL; }
 	if (Smem2!=NULL) {  free(Smem2);  Smem2=NULL; }
 	if (Smem3!=NULL) {  free(Smem3);  Smem3=NULL; }
@@ -252,15 +254,15 @@
 	if (Smem7!=NULL) {  free(Smem7);  Smem7=NULL; }
 	if (Smem8!=NULL) {  free(Smem8);  Smem8=NULL; }
 
-	if (gsln!=NULL)  {  gsln->~GBCSolution(); delete gsln;  gsln=NULL;}
-	if (mem1!=NULL) { mem1->~GBCSolution(); delete mem1;  mem1=NULL;}
-	if (mem2!=NULL) { mem2->~GBCSolution(); delete mem2;  mem2=NULL;}
-	if (mem3!=NULL) { mem3->~GBCSolution(); delete mem3;  mem3=NULL;}
-	if (mem4!=NULL) { mem4->~GBCSolution(); delete mem4;  mem4=NULL;}
-	if (mem5!=NULL) { mem5->~GBCSolution(); delete mem5;  mem5=NULL;}
-	if (mem6!=NULL) { mem6->~GBCSolution(); delete mem6;  mem6=NULL;}
-	if (mem7!=NULL) { mem7->~GBCSolution(); delete mem7;  mem7=NULL;}
-	if (mem8!=NULL) { mem8->~GBCSolution(); delete mem8;  mem8=NULL;}
+	if (gsln!=NULL)  {  delete gsln;  gsln=NULL;}
+	if (mem1!=NULL) { delete mem1;  mem1=NULL;}
+	if (mem2!=NULL) { delete mem2;  mem2=NULL;}
+	if (mem3!=NULL) { delete mem3;  mem3=NULL;}
+	if (mem4!=NULL) { delete mem4;  mem4=NULL;}
+	if (mem5!=NULL) { delete mem5;  mem5=NULL;}
+	if (mem6!=NULL) { delete mem6;  mem6=NULL;}
+	if (mem7!=NULL) { delete mem7;  mem7=NULL;}
+	if (mem8!=NULL) { delete mem8;  mem8=NULL;}
 
 	delete inG1;
 	delete inG2;
@@ -359,8 +361,11 @@
 	}
 		
 	// Find the zero angle of the bore relative to the sighting system.
-	zeroangle=ZeroAngle(df,bc,v,sh,zero,0);
-	
+	// if the zero distance <= 2 yards, it is a preset zero angle used to match the
+	// firing trajectory from another solution
+	if (zero <= 2.0) zeroangle=zero;
+	else zeroangle=ZeroAngle(df,bc,v,sh,zero,0);
+
 	// Generate a solution using the GNU Ballistics library call.
 	numRows = SolveAll(df,bc,v,sh,angle,zeroangle,windspeed,windangle,&(lSolution));
 	
@@ -403,7 +408,7 @@
 		}
 	
 		// Otherwise we assume success, and inform the user of our success.
-		sprintf(txt1,"GNU Ballistics Computer:  Solution Valid.\nSolution's maximum valid range is %d yards\nUse the options in the 'Solution' menu to view results.",numRows-2);
+		sprintf(txt1,"GNU Ballistics Computer:  Solution Valid.\nSolution's maximum valid range is %d yards\nBore angle is %0.5f above sights\nUse the options in the 'Solution' menu to view results.",numRows-2,zeroangle);
 		T->oStatus->value(txt1);
 		EnableMenu((InputWindow*) vd);	
 		
@@ -415,10 +420,6 @@
 		}
 
 		T->gsln=lsln;
-		
-		
-
-	
 	}
 
 	return;	
@@ -511,15 +512,15 @@
 	if (T->Smem7!=NULL) {  free(T->Smem7);  T->Smem7=NULL; }
 	if (T->Smem8!=NULL) {  free(T->Smem8);  T->Smem8=NULL; }
 
-	if (T->gsln!=NULL)  {  T->gsln->~GBCSolution(); delete T->gsln;  T->gsln=NULL;}
-	if (T->mem1!=NULL) { T->mem1->~GBCSolution(); delete T->mem1;  T->mem1=NULL;}
-	if (T->mem2!=NULL) { T->mem2->~GBCSolution(); delete T->mem2;  T->mem2=NULL;}
-	if (T->mem3!=NULL) { T->mem3->~GBCSolution(); delete T->mem3;  T->mem3=NULL;}
-	if (T->mem4!=NULL) { T->mem4->~GBCSolution(); delete T->mem4;  T->mem4=NULL;}
-	if (T->mem5!=NULL) { T->mem5->~GBCSolution(); delete T->mem5;  T->mem5=NULL;}
-	if (T->mem6!=NULL) { T->mem6->~GBCSolution(); delete T->mem6;  T->mem6=NULL;}
-	if (T->mem7!=NULL) { T->mem7->~GBCSolution(); delete T->mem7;  T->mem7=NULL;}
-	if (T->mem8!=NULL) { T->mem8->~GBCSolution(); delete T->mem8;  T->mem8=NULL;}
+	if (T->gsln!=NULL)  {  /*T->gsln->~GBCSolution();*/ delete T->gsln;  T->gsln=NULL;}
+	if (T->mem1!=NULL) { /*T->mem1->~GBCSolution();*/ delete T->mem1;  T->mem1=NULL;}
+	if (T->mem2!=NULL) { /*T->mem2->~GBCSolution();*/ delete T->mem2;  T->mem2=NULL;}
+	if (T->mem3!=NULL) { /*T->mem3->~GBCSolution();*/ delete T->mem3;  T->mem3=NULL;}
+	if (T->mem4!=NULL) { /*T->mem4->~GBCSolution();*/ delete T->mem4;  T->mem4=NULL;}
+	if (T->mem5!=NULL) { /*T->mem5->~GBCSolution();*/ delete T->mem5;  T->mem5=NULL;}
+	if (T->mem6!=NULL) { /*T->mem6->~GBCSolution();*/ delete T->mem6;  T->mem6=NULL;}
+	if (T->mem7!=NULL) { /*T->mem7->~GBCSolution();*/ delete T->mem7;  T->mem7=NULL;}
+	if (T->mem8!=NULL) { /*T->mem8->~GBCSolution();*/ delete T->mem8;  T->mem8=NULL;}
 	
 
 	// Turn the memory labels back to black to show they are null.
@@ -565,7 +566,7 @@
 	
 	// Spawn a new RangeWindow using the current solution to populate it.
 	if (T->gsln != NULL && T->gsln->sln != NULL){
-		new RangeWindow(600,400,T->gsln);
+		new RangeWindow(760,520,T->gsln);
 	}
 	else {
 		T->oStatus->value("Error creating Range Window.  Unknown Error.");
@@ -672,40 +673,43 @@
 	
 	InputWindow* T = (InputWindow*)v;
 	
-	// A solution for locally working with gsln (hence the name lsln)
-	GBCSolution* lsln = NULL;
-	
 	// Get the file name to load 
 	char* fname=NULL;
 	fname = fl_file_chooser("Please select a file to open.","*.gbc","",0);
 	if (fname==NULL) {
 		T->oStatus->value("GNU Ballistic Computer:  Error opening file!");
 		return;
-	}
+	}
+	
+	T->OpenFile(fname);
+}
+	
+void InputWindow::OpenFile(char * fname) {
+
+	// A solution for locally working with gsln (hence the name lsln)
+	GBCSolution* lsln = NULL;
 	
 	// and open it for binary read.
 	FILE* ofile = fopen(fname,"rb");
 	
-
-	
 	// Free an old solution if there is one, because we want to
 	// write over it.
-	if (T->gsln != NULL) {
-		free(T->gsln);
-		T->gsln=NULL;
+	if (gsln != NULL) {
+		delete(gsln);
+		gsln=NULL;
 	}
 	
 	// Allocate some space for the loaded solution.
 	if (lsln != NULL) {
-		free(lsln);
+		delete(lsln);
 		lsln=NULL;
 	}
 
 	// Assign some new memory for lsln.
-	lsln = (GBCSolution*)malloc(sizeof(GBCSolution));
+	lsln = new GBCSolution; // (GBCSolution*)malloc(sizeof(GBCSolution));
 	
 	if (lsln==NULL){
-		T->oStatus->value("GNU Ballistic Computer:  Memory allocation error.");
+		oStatus->value("GNU Ballistic Computer:  Memory allocation error.");
 		return;
 	}
 	
@@ -716,15 +720,15 @@
 	fclose(ofile);
 	
 	if (read!=sizeof(GBCSolution)){
-		T->oStatus->value("GNU Ballistic Computer:  Error reading file data!\nPlease ensure the file is a valid GNUBC solution.");
+		oStatus->value("GNU Ballistic Computer:  Error reading file data!\nPlease ensure the file is a valid GNUBC solution.");
 		if (lsln!=NULL) {
-			free(lsln);
+			delete(lsln);
 			lsln=NULL;
 		}
 
-		if (T->gsln!=NULL) {
-			free(T->gsln);
-			T->gsln=NULL;
+		if (gsln!=NULL) {
+			delete(gsln);
+			gsln=NULL;
 		}
 		
 		return;
@@ -732,51 +736,51 @@
 			
 
 	// Set the parent's solution pointer to the local one we just imported.
-	T->gsln=lsln;
+	gsln=lsln;
 
 	// Load the solution data into the INPUT fields in the InputWindow.
 	char buff[1024];
-	T->inName->value(lsln->Name());
-	sprintf(buff,"%.3f",lsln->BC());  T->inBC->value(buff);
-	sprintf(buff,"%.2f",lsln->SightHeight());  T->inSH->value(buff);
-	sprintf(buff,"%d",lsln->MuzzleVelocity());  T->inMV->value(buff);
-	sprintf(buff,"%d",lsln->ShootingAngle());  T->inAngle->value(buff);
-	sprintf(buff,"%d",lsln->ZeroRange());  T->inZero->value(buff);
-	sprintf(buff,"%d",lsln->WindSpeed());  T->inVwind->value(buff);
-	sprintf(buff,"%d",lsln->WindAngle());  T->inAwind->value(buff);
-	sprintf(buff,"%d",lsln->Temp());  T->inTemp->value(buff);
-	sprintf(buff,"%.2f",lsln->Pressure());  T->inPressure->value(buff);
-	sprintf(buff,"%d",lsln->Humidity());  T->inHumidity->value(buff);
-	sprintf(buff,"%d",lsln->Altitude());  T->inAltitude->value(buff);	
-	sprintf(buff,"%d",lsln->Weight());  T->inWeight->value(buff);
-	T->ckWeather->value(lsln->UseWeather());
-	T->cb_ckWeather(o,v);
-	
-	T->inG1->value(0);
-	T->inG2->value(0);
-	T->inG5->value(0);
-	T->inG6->value(0);
-	T->inG7->value(0);
-	T->inG8->value(0);
-	
-	
-	if (lsln->df==G1) T->inG1->set();
-	if (lsln->df==G2) T->inG2->set();
-	if (lsln->df==G5) T->inG5->set();
-	if (lsln->df==G6) T->inG6->set();
-	if (lsln->df==G7) T->inG7->set();
-	if (lsln->df==G8) T->inG8->set();
+	inName->value(lsln->Name());
+	sprintf(buff,"%.3f",lsln->BC());  inBC->value(buff);
+	sprintf(buff,"%.2f",lsln->SightHeight());  inSH->value(buff);
+	sprintf(buff,"%d",lsln->MuzzleVelocity());  inMV->value(buff);
+	sprintf(buff,"%d",lsln->ShootingAngle());  inAngle->value(buff);
+	sprintf(buff,"%d",lsln->ZeroRange());  inZero->value(buff);
+	sprintf(buff,"%d",lsln->WindSpeed());  inVwind->value(buff);
+	sprintf(buff,"%d",lsln->WindAngle());  inAwind->value(buff);
+	sprintf(buff,"%d",lsln->Temp());  inTemp->value(buff);
+	sprintf(buff,"%.2f",lsln->Pressure());  inPressure->value(buff);
+	sprintf(buff,"%d",lsln->Humidity());  inHumidity->value(buff);
+	sprintf(buff,"%d",lsln->Altitude());  inAltitude->value(buff);	
+	sprintf(buff,"%d",lsln->Weight());  inWeight->value(buff);
+	ckWeather->value(lsln->UseWeather());
+	cb_ckWeather(NULL,this);
+	
+	inG1->value(0);
+	inG2->value(0);
+	inG5->value(0);
+	inG6->value(0);
+	inG7->value(0);
+	inG8->value(0);
+	
+	
+	if (lsln->df==G1) inG1->set();
+	if (lsln->df==G2) inG2->set();
+	if (lsln->df==G5) inG5->set();
+	if (lsln->df==G6) inG6->set();
+	if (lsln->df==G7) inG7->set();
+	if (lsln->df==G8) inG8->set();
 
 	// We don't actually have a valid solution, so make sure to set the solution
 	// double* pointer to NULL before we call solve.
-	T->gsln->sln=NULL;
+	gsln->sln=NULL;
 	
 	// And now solve the loaded parameters.
-	DisableMenu(T);
-	T->cb_Solve(o,v);
+	DisableMenu(this);
+	cb_Solve(NULL,this);
 	
 	// Finally inform the user of our success.
-	T->oStatus->value("GNU Ballistics Computer:  File loaded successfully.");
+	oStatus->value("GNU Ballistics Computer:  File loaded successfully.");
 	
 	return;
 
@@ -790,8 +794,22 @@
 	GBCSolution* sln = T->gsln;
 	GBCSolution* lmem1 = T->mem1;
 	GBCSolution* lmem2 = T->mem2;
+	GBCSolution* lmem3 = T->mem3;
+	
+	new PlotWindow(700,500,sln,lmem1,lmem2,lmem3);
+
+}
+
+void InputWindow::cb_Target(Fl_Widget* o, void* v){
+
+	InputWindow* T = (InputWindow*)v;
+
+	GBCSolution* sln = T->gsln;
+	GBCSolution* lmem1 = T->mem1;
+	GBCSolution* lmem2 = T->mem2;
+	GBCSolution* lmem3 = T->mem3;
 	
-	new PlotWindow(700,500,sln,lmem1,lmem2);
+	new TargetWindow(600,600,sln,lmem1,lmem2,lmem3);
 
 }
 
@@ -801,7 +819,6 @@
 	T->oStatus->value("GNU Ballistics Computer: Stored to Memory 1");
 	
 	if (T->mem1 != NULL) {
-		if (T->mem1->sln!=NULL) free (T->mem1->sln);
 		delete(T->mem1);
 	}
 	
diff -x Makefile.in -x autom4te.cache -x configure -x aclocal.m4 -urN gebc-1.07/InputWindow.h gebc-1.07-mike/InputWindow.h
--- gebc-1.07/InputWindow.h	2008-03-01 04:47:22.000000000 +0900
+++ gebc-1.07-mike/InputWindow.h	2011-01-27 13:23:38.415065778 +0800
@@ -29,12 +29,16 @@
 #include "AboutWindow.h"
 #include "LicenseWindow.h"
 #include "PlotWindow.h"
+#include "TargetWindow.h"
 
 class InputWindow : public Fl_Window{
  
    public:
       InputWindow(int w, int h, const char* title );
       ~InputWindow();
+      
+      void OpenFile(char *fname);
+      
       Fl_Button* btSolve;
 	  Fl_Button* btReset;
 	  Fl_Button* btStdAtmosphere;
@@ -81,7 +85,7 @@
 	  Fl_Float_Input* inSH;
 	  Fl_Int_Input* inMV;
       Fl_Int_Input* inAngle;
-	  Fl_Int_Input* inZero;
+	  Fl_Float_Input* inZero;
       Fl_Int_Input* inVwind;
 	  Fl_Int_Input* inAwind;
 	  Fl_Int_Input* inTemp; Fl_Float_Input* inPressure;
@@ -107,6 +111,7 @@
 	   	  Fl_Menu_Item m_Analyze; 
 			Fl_Menu_Item mc_Table;
 			Fl_Menu_Item mc_Plot; 
+			Fl_Menu_Item mc_Target;
 			Fl_Menu_Item mc_Compare;
 			
 	   	  Fl_Menu_Item m_Aids;
@@ -154,6 +159,7 @@
 	  static void cb_Save(Fl_Widget*, void*);
 	  static void cb_Open(Fl_Widget*, void*);
 	  static void cb_Plot(Fl_Widget*, void*);
+	  static void cb_Target(Fl_Widget*, void*);
 	  static void cb_Options(Fl_Widget*, void*);
 	  
 	  static void cb_Store1(Fl_Widget*, void*);
diff -x Makefile.in -x autom4te.cache -x configure -x aclocal.m4 -urN gebc-1.07/Makefile.am gebc-1.07-mike/Makefile.am
--- gebc-1.07/Makefile.am	2008-03-01 05:41:59.000000000 +0900
+++ gebc-1.07-mike/Makefile.am	2011-01-24 22:04:11.870064531 +0800
@@ -10,6 +10,7 @@
 gebc_SOURCES = \
 	InputWindow.cpp \
 	PlotWindow.cpp \
+	TargetWindow.cpp \
 	RangeWindow.cpp \
 	LicenseWindow.cpp \
 	AboutWindow.cpp \
@@ -18,6 +19,7 @@
 	GNU_Ballistics.cpp \
 	InputWindow.h \
 	PlotWindow.h \
+	TargetWindow.h \
 	RangeWindow.h \
 	LicenseWindow.h \
 	AboutWindow.h \
diff -x Makefile.in -x autom4te.cache -x configure -x aclocal.m4 -urN gebc-1.07/PlotWindow.cpp gebc-1.07-mike/PlotWindow.cpp
--- gebc-1.07/PlotWindow.cpp	2008-03-01 04:47:22.000000000 +0900
+++ gebc-1.07-mike/PlotWindow.cpp	2011-01-28 22:07:32.783066399 +0800
@@ -1,11 +1,19 @@
 #include "PlotWindow.h"
 
-PlotWindow::PlotWindow(int w, int h, GBCSolution* Gsln, GBCSolution* GMEM1, GBCSolution* GMEM2) : Fl_Window(w,h,"Solution Visualization Tools"){
+#define PT_PATH		0
+#define PT_DROP		1
+#define PT_VELOCITY	2
+#define PT_HVELOCITY	3
+#define PT_ENERGY	4
+#define PT_WINDAGE	5
+
+PlotWindow::PlotWindow(int w, int h, GBCSolution* Gsln, GBCSolution* GMEM1, GBCSolution* GMEM2, GBCSolution* GMEM3) : Fl_Window(w,h,"Solution Visualization Tools"){
 	
 	// Store a pointer to the calling solution.
 	gsln=Gsln;
 	mem1=GMEM1;
 	mem2=GMEM2;
+	mem3=GMEM3;
 	
 	x_click=0;
 	y_click=0;
@@ -33,10 +41,10 @@
 	menu->down_box(FL_NO_BOX);
 
 	// Put in a range slider for selecting the chart's range.	
-	sl_x = new Fl_Value_Slider(150,40,350,30,"Range (yds)");
+	sl_x = new Fl_Value_Slider(150,30,350,30,"Range (yds)");
 	sl_x->align(FL_ALIGN_RIGHT);
 	sl_x->value(200);
-	sl_x->minimum(200);
+	sl_x->minimum(50);
 	sl_x->maximum(gsln->MaxRows());
 	sl_x->type(FL_HOR_NICE_SLIDER);
 	sl_x->callback(cb_slUpdate,this);
@@ -45,39 +53,58 @@
 	
 	//Fl_Button* btPlot = new Fl_Button(600,40,70,30,"UPDATE");
 	//btPlot->callback(cb_btPlot,this);
+	
+	Fl_Menu_Item guideitems[]={
+	   {"None",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"1,5 MIL",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"1-5 MIL",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"1-10 MIL",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"1-5,10 MIL",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"2,10 MOA",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"2,4,6,8,10 MOA",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"2-20 MOA",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"2-10,20 MOA",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"1-5 Degrees",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"5,10,15 Degree",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {0}
+	   };
+	cScopeGuides = new Fl_Choice(290,65,150,30,"Scope Guides");
+	cScopeGuides->copy(guideitems);
+	cScopeGuides->value(1);
 	
 	btMem1 = new Fl_Check_Button(590,30,20,20,"Memory 1");
 	btMem2 = new Fl_Check_Button(590,50,20,20,"Memory 2");
+	btMem3 = new Fl_Check_Button(590,70,20,20,"Memory 3");
 	btMem1->align(FL_ALIGN_RIGHT);
 	btMem2->align(FL_ALIGN_RIGHT);
+	btMem3->align(FL_ALIGN_RIGHT);
 	btMem1->labelcolor(FL_RED);
 	btMem2->labelcolor(FL_DARK_GREEN);
+	btMem3->labelcolor(FL_BLACK);
 	btMem1->callback(cb_Mem1,this);
 	btMem2->callback(cb_Mem2,this);
-		
+	btMem3->callback(cb_Mem2,this);
+	
 	if (mem1==NULL) btMem1->deactivate();
 	if (mem2==NULL) btMem2->deactivate();
+	if (mem3==NULL) btMem3->deactivate();
 	
 	if (mem1!=NULL) btMem1->tooltip(mem1->Name());
 	if (mem2!=NULL) btMem2->tooltip(mem2->Name());
+	if (mem3!=NULL) btMem3->tooltip(mem3->Name());
 	
-	rbPlotPath = new Fl_Round_Button(20,30,30,20,"Path (inches)");
-	rbPlotVelocity = new Fl_Round_Button(20,50,30,20,"Velocity");
-	rbPlotEnergy = new Fl_Round_Button(20,70,30,20,"Energy");
-	
-	rbPlotPath->type(FL_RADIO_BUTTON);
-	rbPlotVelocity->type(FL_RADIO_BUTTON);
-	rbPlotEnergy->type(FL_RADIO_BUTTON);
-	
-	rbPlotPath->callback(cb_btPlot,this);
-	rbPlotVelocity->callback(cb_btPlot,this);
-	rbPlotEnergy->callback(cb_btPlot,this);
-	
-	rbPlotPath->value(1);
-	
-	rbPlotPath->align(FL_ALIGN_RIGHT);
-	rbPlotVelocity->align(FL_ALIGN_RIGHT);
-	rbPlotEnergy->align(FL_ALIGN_RIGHT);
+	Fl_Menu_Item plottypeitems[]={
+	   {"Path (inches)",0,(Fl_Callback*)cb_PlotType, this, 0},
+	   {"Drop (inches)",0,(Fl_Callback*)cb_PlotType, this, 0},
+	   {"Velocity",0,(Fl_Callback*)cb_PlotType, this, 0},
+	   {"Horizontal Velocity",0,(Fl_Callback*)cb_PlotType, this, 0},
+	   {"Energy",0,(Fl_Callback*)cb_PlotType, this, 0},
+	   {"Wind Drift",0,(Fl_Callback*)cb_PlotType, this, 0},
+	   {0}
+	   };
+	cPlotType = new Fl_Choice(35,65,130,30,"Plot");
+	cPlotType->copy(plottypeitems);
+	cPlotType->value(0);
 	
 	end();
 	show();
@@ -89,11 +116,11 @@
 
 	delete menu;
 	delete sl_x;
-	delete rbPlotPath;
-	delete rbPlotVelocity;
-	delete rbPlotEnergy;
 	delete btMem1;
 	delete btMem2;
+	delete btMem3;
+	delete cScopeGuides;
+	delete cPlotType;
 	
 
 }
@@ -104,10 +131,14 @@
 	// Let the window draw itself first.
 	Fl_Window::draw();
 	
-	if (rbPlotPath->value()==1) PlotPath();
-	else if (rbPlotEnergy->value()==1) PlotEnergy();
-	else if (rbPlotVelocity->value()==1) PlotVelocity();
-
+	switch (cPlotType->value()) {
+	   case PT_PATH  :   PlotPath(PT_PATH);		break;
+	   case PT_DROP  :   PlotPath(PT_DROP);		break;
+	   case PT_ENERGY:   PlotEnergy();		break;
+	   case PT_VELOCITY: PlotVelocity(PT_VELOCITY);	break;
+	   case PT_HVELOCITY:PlotVelocity(PT_HVELOCITY);break;
+	   case PT_WINDAGE:  PlotPath(PT_WINDAGE);	break;
+	   }
 }
 
 int PlotWindow::handle(int evt){
@@ -126,59 +157,118 @@
 }
 
 
-
-void PlotWindow::PlotPath(void){
-
-	int w = this->w();
-	int h = this->h();
-	
-	int xmin = 5;
-	int xmax = w-5;
-	int ymin = 100;
-	int ymax = h-5;
-	
-	int y0 = (ymax-ymin)/2 + ymin;
-	
-	
-	// The gridlines look best with 15-25 graduations in x, so we set some basic defaults here.
-	x_ticks=25;
-	if (sl_x->value() > 500) x_ticks=50;
-	if (sl_x->value() > 1000) x_ticks=100;
-	if (sl_x->value() > 2000) x_ticks=250;
-	if (sl_x->value() > 4000) x_ticks=500;
-	
-
-	// We need to find the max and min y-values to determine our y scale and y-ticks
-	double _miny=0;
-	double _maxy=0;
-	
-
-		
-	for (int e=0;e<sl_x->value();e++){
-		if (gsln->GetPath(e) > _maxy) _maxy=gsln->GetPath(e);
-		if (gsln->GetPath(e) < _miny) _miny=gsln->GetPath(e);
-	}
-
-	int x_range=(int)sl_x->value();
-	double y_range=0;
-	
-	if (fabs(_miny) > fabs(_maxy)) y_range = fabs(2.5*_miny);
-	else y_range = fabs(2.5*_maxy);
-	
-	double x_scale = (double)(xmax-xmin) / (double)x_range;
-	double y_scale = (double)(ymax-ymin) / (double)y_range;
-	
-
-
-	
-	// Now do our custom drawing.
-	fl_draw_box(FL_FLAT_BOX,xmin,ymin,w-10,h-ymin-5,FL_WHITE);
-
-	// Draw the x-axis.
-	fl_color(FL_BLACK);
-	fl_line_style(FL_SOLID,2);
-	fl_line(xmin,y0,xmax,y0);
-	
+/* 
+    PlotMem()
+    
+    Plot the requested data from a given GBCSolution (the current solution or a memory)
+    
+    mode = 0: Path, 1: Energy, 2: Velocity, 3: Wind Drift
+
+*/
+
+void PlotWindow::PlotMem(GBCSolution* mem, int mode){
+
+  int x1,x2;
+  double y1,y2;
+  int px1, px2, py1,py2;
+  
+  x1=(int)mem->GetRange(0);
+  switch (mode) {
+	case PT_PATH:
+		y1=mem->GetPath(0);
+		break;
+	case PT_DROP:
+		y1=mem->GetDrop(0);
+		break;
+	case PT_ENERGY:
+		y1=mem->GetEnergy(0);
+		break;
+	case PT_VELOCITY:
+		y1=mem->GetVelocity(0);
+		break;
+	case PT_HVELOCITY:
+		y1=mem->GetVx(0);
+		break;
+	case PT_WINDAGE:
+		y1=mem->GetWindage(0);
+		break;
+  }
+
+  int m=this->gsln->MaxRows();
+
+  for (int n=1;n<x_range && n<m ;n++){
+	x2=(int)mem->GetRange(n);
+	switch (mode) {
+		case PT_PATH:
+			y2=mem->GetPath(n);
+			break;
+		case PT_DROP:
+			y2=mem->GetDrop(n);
+			break;
+		case PT_ENERGY:
+			y2=mem->GetEnergy(n);
+			break;
+		case PT_VELOCITY:
+			y2=mem->GetVelocity(n);
+			break;
+		case PT_HVELOCITY:
+			y2=mem->GetVx(n);
+			break;
+		case PT_WINDAGE:
+			y2=mem->GetWindage(n);
+			break;
+	}
+	
+	// Translate the x,y values into scaled pixels.
+	px1=(int)(xmin+x_scale*(double)x1);
+	px2=(int)(xmin+x_scale*(double)x2);
+	
+	py1=(int)((y0)-(double)y_scale*(double)y1);
+	py2=(int)((y0)-(double)y_scale*(double)y2);
+	
+	if (py2>=ymax) break;
+	if (px2>=xmax) break;
+	
+	// Plot the points.
+	if (px1>xmin && px1<xmax && py1<ymax && py1>ymin)
+		fl_line(px1,py1,px2,py2);
+	
+	x1=x2;
+	y1=y2;
+	}
+
+}
+
+
+/*
+   SetupPlot()
+   
+   Calculate some common parameters for the plots
+   This code was common to all plots (Path, Energy, Velocity) and was consolidated here
+   
+   Requires x_range and y_range to be set before calling
+*/
+
+void PlotWindow::SetupPlot(void){
+
+	int w = this->w();
+	int h = this->h();
+	
+	xmin = 5;
+	xmax = w-5;
+	ymin = 100;
+	ymax = h-5;
+
+	x_scale = (double)(xmax-xmin) / (double)x_range;
+	y_scale = (double)(ymax-ymin) / (double)y_range;
+	
+	// The gridlines look best with 15-25 graduations in x, so we set some basic defaults here.
+	x_ticks=25;
+	if (sl_x->value() > 500) x_ticks=50;
+	if (sl_x->value() > 1000) x_ticks=100;
+	if (sl_x->value() > 2000) x_ticks=250;
+	if (sl_x->value() > 4000) x_ticks=500;
+
 	// The y-axis looks best with about 7-12 ticks, so we scale it here reasonably.
 	y_ticks=1;
 	if (y_range > 10) y_ticks=2;
@@ -189,6 +279,34 @@
 	if (y_range > 400) y_ticks=100;
 	if (y_range > 800) y_ticks=250;
 	if (y_range > 1600) y_ticks=500;
+	if (y_range > 3200) y_ticks=1000;
+	if (y_range > 6400) y_ticks=2000;
+	if (y_range > 12800) y_ticks=4000;
+	if (y_range > 25600) y_ticks=8000;
+	if (y_range > 51200) y_ticks=16000;
+	if (y_range > 102400) y_ticks=32000;
+	if (y_range > 204800) y_ticks=64000;
+
+}
+
+
+/*
+   DrawPlotBackground()
+   
+   Draw the graph background, axis, scale etc
+   Code was common to all plots and has been consolidated here
+   
+   Requires SetupPlot to have been called and y0 set first
+*/
+
+void PlotWindow::DrawPlotBackground(int mode, const char *ylabel){
+	// Now do our custom drawing.
+	fl_draw_box(FL_FLAT_BOX,xmin,ymin,w()-10,h()-ymin-5,FL_WHITE);
+
+	// Draw the x-axis.
+	fl_color(FL_BLACK);
+	fl_line_style(FL_SOLID,2);
+	fl_line(xmin,y0,xmax,y0);
 
 	double px;
 	fl_color(FL_BLACK);
@@ -196,11 +314,15 @@
 	char txt[64];
 	int r=0;
 	double txtw=0;
+
+	int tick_top=ymax;
+	if (mode != PT_PATH && mode != PT_DROP && mode != PT_WINDAGE) tick_top=y0;
+
 	// Draw X gridlines every x_ticks yds and label them.
 	for (px=xmin;px<xmax;px+=((double)x_ticks*x_scale)){
 		//fl_line((int)px,y_bottom,(int)px,y_top);
 		fl_line_style(FL_DOT,1);
-		fl_line((int)px,(int)ymin,(int)px,(int)ymax);
+		fl_line((int)px,(int)ymin,(int)px,tick_top);
 		sprintf(txt,"%d",r*x_ticks);
 		if (r%2==0 && r>0) {
 			txtw=fl_width(txt);
@@ -217,131 +339,49 @@
 	for (py=y0;py>=ymin;py-=((double)y_ticks*y_scale)){
 		if (r>0){
 			fl_line(xmin,(int)py,xmax,(int)py);
-			sprintf(txt,"+%d\"",r*y_ticks);
+			sprintf(txt,"+%d%s",r*y_ticks, ylabel);
 			fl_draw(txt,xmin+10,(int)(py+fl_height()/2));
 		}
 		r++;
 	}
 	
 	// Draw Y hashmarks every 1 y_tick going down
-	r=0;
-	for (py=y0;py<=ymax;py+=((double)y_ticks*y_scale)){
+	if (mode==PT_PATH || mode==PT_DROP || mode==PT_WINDAGE) {
+	   r=0;
+	   for (py=y0;py<=ymax;py+=((double)y_ticks*y_scale)){
 		if (r>0){
 			fl_line(xmin,(int)py,xmax,(int)py);
-			sprintf(txt,"-%d\"",r*y_ticks);
+			sprintf(txt,"-%d%s",r*y_ticks, ylabel);
 			if (py+fl_height()/2<ymax)	fl_draw(txt,xmin+10,(int)(py+fl_height()/2));
 		}
 		r++;
+	   }
 	}
-	
-	int x1,x2;
-	double y1,y2;
-	
-	// For the pixel locations to plot.
-	int px1, px2, py1,py2;
-	
-	x1=(int)this->gsln->GetRange(0);
-	y1=this->gsln->GetPath(0);
-		
-	int m=this->gsln->MaxRows();
-	
+
+}
+
+
+void PlotWindow::DrawPlotData(int mode){
+
 	fl_color(FL_BLUE);
 	fl_line_style(FL_SOLID,1);
-	
-	for (int n=1;n<x_range && n<m ;n++){
-		x2=(int)this->gsln->GetRange(n);
-		y2=this->gsln->GetPath(n);
-		
-		// Translate the x,y values into scaled pixels.
-		px1=(int)(xmin+x_scale*(double)x1);
-		px2=(int)(xmin+x_scale*(double)x2);
-		
-		py1=(int)((y0)-(double)y_scale*(double)y1);
-		py2=(int)((y0)-(double)y_scale*(double)y2);
-	
-		if (py2>=ymax) break;
-		if (px2>=xmax) break;
-		
-		// Plot the points.
-		fl_line(px1,py1,px2,py2);
-		
-		x1=x2;
-		y1=y2;
-		
-
-	}
+	PlotMem(this->gsln, mode);
 	
 	if (btMem1->value()==1){
-	
-		x1=(int)this->mem1->GetRange(0);
-		y1=this->mem1->GetPath(0);
-		
-		int m=this->gsln->MaxRows();
-	
 		fl_color(FL_RED);
 		fl_line_style(FL_SOLID,1);
-		
-		for (int n=1;n<x_range && n<m ;n++){
-			x2=(int)this->mem1->GetRange(n);
-			y2=this->mem1->GetPath(n);
-			
-			// Translate the x,y values into scaled pixels.
-			px1=(int)(xmin+x_scale*(double)x1);
-			px2=(int)(xmin+x_scale*(double)x2);
-			
-			py1=(int)((y0)-(double)y_scale*(double)y1);
-			py2=(int)((y0)-(double)y_scale*(double)y2);
-		
-			if (py2>=ymax) break;
-			if (px2>=xmax) break;
-			
-			// Plot the points.
-			if (px1>xmin && px1<xmax && py1<ymax && py1>ymin)
-				fl_line(px1,py1,px2,py2);
-			
-			x1=x2;
-			y1=y2;
-			
-
+		PlotMem(mem1, mode);
 		}
-	}
-	
-	
 	if (btMem2->value()==1){
-	
-		x1=(int)this->mem2->GetRange(0);
-		y1=this->mem2->GetPath(0);
-		
-		int m=this->gsln->MaxRows();
-	
 		fl_color(FL_GREEN);
 		fl_line_style(FL_SOLID,1);
-		
-		for (int n=1;n<x_range && n<m ;n++){
-			x2=(int)this->mem2->GetRange(n);
-			y2=this->mem2->GetPath(n);
-			
-			// Translate the x,y values into scaled pixels.
-			px1=(int)(xmin+x_scale*(double)x1);
-			px2=(int)(xmin+x_scale*(double)x2);
-			
-			py1=(int)((y0)-(double)y_scale*(double)y1);
-			py2=(int)((y0)-(double)y_scale*(double)y2);
-		
-			if (py2>=ymax) break;
-			if (px2>=xmax) break;
-			
-			// Plot the points.
-			if (px1>xmin && px1<xmax && py1<ymax && py1>ymin)
-				fl_line(px1,py1,px2,py2);
-			
-			x1=x2;
-			y1=y2;
-			
-
+		PlotMem(mem2, mode);
+		}
+	if (btMem3->value()==1){
+		fl_color(FL_BLACK);
+		fl_line_style(FL_SOLID,1);
+		PlotMem(mem3, mode);
 		}
-	}
-	
 	
 	if (x_click>xmin && x_click<xmax && y_click>ymin && y_click<ymax){
 		// If the user clicks, show the coordinates they clicked on.
@@ -353,40 +393,139 @@
 		fl_draw(lbl_point,x_click+5, y_click-5);
 		fl_rectf(x_click-2, y_click-2,4,4);
 	}
-	
-	
-	
+
 	// Draw the frame around it last to make it all pretty.
-	fl_frame("aaaa",5,100,w-10,h-105);
+	fl_frame("aaaa",5,100,w()-10,h()-105);
+
+}
+
+
+void PlotWindow::PlotPath(int ptype){
+
+	// We need to find the max and min y-values to determine our y scale and y-ticks
+	double _miny=0;
+	double _maxy=0;
 	
+	if (ptype == PT_WINDAGE) {
+	   for (int e=0;e<sl_x->value();e++){
+		if (gsln->GetWindage(e) > _maxy) _maxy=gsln->GetWindage(e);
+		if (gsln->GetWindage(e) < _miny) _miny=gsln->GetWindage(e);
+	   }
+	} else if (ptype == PT_DROP) {
+	   for (int e=0;e<sl_x->value();e++){
+		if (gsln->GetDrop(e) > _maxy) _maxy=gsln->GetDrop(e);
+		if (gsln->GetDrop(e) < _miny) _miny=gsln->GetDrop(e);
+	   }
+	} else {
+	   for (int e=0;e<sl_x->value();e++){
+		if (gsln->GetPath(e) > _maxy) _maxy=gsln->GetPath(e);
+		if (gsln->GetPath(e) < _miny) _miny=gsln->GetPath(e);
+	   }
+	}
+
+	x_range=(int)sl_x->value();
+	
+	_miny*=1.1;
+	if (_miny > -4) _miny=-4;
+	if (_maxy < 3) _maxy=3;
+	else if (_maxy < 10) _maxy *= 2;
+	else _maxy*=1.3;
+	
+	if (_maxy < fabs(_miny)/3) _maxy = fabs(_miny)/3;
+	else if (fabs(_miny) < (_maxy/3)) _miny = -_maxy/3;
+	
+	y_range = _maxy - _miny;
+	
+	SetupPlot();
+	y0 = ymax + (_miny * y_scale);
+
+	DrawPlotBackground(ptype, "\"");
+
+	// draw +/- 1 and 5 MOA or MIL lines
+	if (cScopeGuides->value() > 0) {
+	   int sgmode=cScopeGuides->value();
+	   double pix_inset=50;
+
+	   // one MIL - not quite equal to one real milliradian
+	   long double oneunit = 3.1415 / 3200;
+
+	   if (sgmode >= 5)
+	        oneunit=oneunit / 3.438; // use one moa instead
+	   if (sgmode >= 9)
+	        oneunit=0.0174532925; // use one degree
+	   
+	   double range_inset=pix_inset/x_scale;
+	   double near, far;
+	   int start, stop, step, step2, g;
+	   char txt[10];
+	   
+	   step2=0;
+	   switch (sgmode) {
+	      case 1: start=1; stop=5;  step=4; break;		 // 1,5 MIL
+	      case 2: start=1; stop=5;  step=1; break;		 // 1-5 MIL
+	      case 3: start=1; stop=10; step=1; break;		 // 1-10 MIL
+	      case 4: start=1; stop=5;  step=1; step2=5; break;	 // 1-5,10 MIL
+	      case 5: start=2; stop=10; step=8; break;		 // 2,10 MOA
+	      case 6: start=2; stop=10; step=2; break;		 // 2,4,6,8,10 MOA
+	      case 7: start=2; stop=20; step=2; break;		 // 2-20 MOA
+	      case 8: start=2; stop=10; step=2; step2=10; break; // 2,4,6,8,10,20 MOA
+	      case 9:  start=1; stop=5; step=1; break;		 // 1-10 Degrees
+	      case 10: start=5; stop=15; step=5; break;		 // 5,10,15 Degrees
+	      
+	      default: start=1; stop=1; step=1; break;
+	      }
+
+	   fl_clip(5,100,w()-10,h()-105);
+	   for (g=start; g<=stop; g+=step) {
+	       near=tanf(oneunit*g) * range_inset * 36.0; // and convert yards->inches
+	       far =tanf(oneunit*g) * (x_range - range_inset) * 36.0;
+	       
+	       if (near < y_range/2) {
+	          fl_line(xmin+pix_inset,y0-(near*y_scale),xmax-pix_inset,y0-(far*y_scale));
+	          if (g==start) {
+	             if (sgmode>=9) sprintf(txt, "+%d Deg", g);
+	             else if (sgmode>=5) sprintf(txt, "+%d MOA", g);
+	             else sprintf(txt, "+%d MIL", g);
+	             }
+	          else sprintf(txt, "+%d", g);
+	          fl_draw(txt, xmax-pix_inset+3, y0-(far*y_scale));
+	       
+	          fl_line(xmin+pix_inset,y0+(near*y_scale),xmax-pix_inset,y0+(far*y_scale));
+	          if (g==start) {
+	             if (sgmode>=9) sprintf(txt, "-%d Deg", g);
+	             else if (sgmode>=5) sprintf(txt, "-%d MOA", g);
+	             else sprintf(txt, "-%d MIL", g);
+	             }
+	          else sprintf(txt, "-%d", g);
+	          fl_draw(txt, xmax-pix_inset+3, y0+(far*y_scale));
+	          }
+	       }
+	   if (step2 > 0) {
+	       g+=step2-step;
+	       near=tanf(oneunit*g) * range_inset * 36.0;
+	       far =tanf(oneunit*g) * (x_range - range_inset) * 36.0;
+
+	       if (near < y_range/2) {
+	          fl_line(xmin+pix_inset,y0-(near*y_scale),xmax-pix_inset,y0-(far*y_scale));
+	          sprintf(txt, "+%d", g);
+	          fl_draw(txt, xmax-pix_inset+3, y0-(far*y_scale));
+	       
+	          fl_line(xmin+pix_inset,y0+(near*y_scale),xmax-pix_inset,y0+(far*y_scale));
+	          sprintf(txt, "-%d", g);
+	          fl_draw(txt, xmax-pix_inset+3, y0+(far*y_scale));
+	          }
+	       }
+	      
+	   fl_pop_clip();
+	   }
+	   
+	DrawPlotData(ptype);
+
 	return;
-
-
-
 }
 
 void PlotWindow::PlotEnergy(void){
-
-
-	int w = this->w();
-	int h = this->h();
-	
-	int xmin = 5;
-	int xmax = w-5;
-	int ymin = 100;
-	int ymax = h-5;
-	
-	int y0 = (ymax)-50;
-	
-	
-	// The gridlines look best with 15-25 graduations in x, so we set some basic defaults here.
-	x_ticks=25;
-	if (sl_x->value() > 500) x_ticks=50;
-	if (sl_x->value() > 1000) x_ticks=100;
-	if (sl_x->value() > 2000) x_ticks=250;
-	if (sl_x->value() > 4000) x_ticks=500;
-	
-
+
 	// We need to find the max y-value to determine our y scale and y-ticks
 
 	double _maxy=0;
@@ -396,221 +535,23 @@
 		if (gsln->GetPath(e) > _maxy) _maxy=gsln->GetEnergy(e);
 	}
 
-	int x_range=(int)sl_x->value();
-	double y_range=0;
+	x_range=(int)sl_x->value();
 	
-	if (fabs(_miny) > fabs(_maxy)) y_range = fabs(1.5*_miny);
+	if (fabs(_miny) > fabs(_maxy))
+	     y_range = fabs(1.5*_miny);
 	else y_range = fabs(1.5*_maxy);
-	
-	double x_scale = (double)(xmax-xmin) / (double)x_range;
-	double y_scale = (double)(ymax-ymin) / (double)y_range;
-	
-	// Now do our custom drawing.
-	fl_draw_box(FL_FLAT_BOX,xmin,ymin,w-10,h-ymin-5,FL_WHITE);
-
-	
-	// Draw the x-axis.
-	fl_color(FL_BLACK);
-	fl_line_style(FL_SOLID,2);
-	fl_line(xmin,y0,xmax,y0);
-	
-	// The y-axis looks best with about 7-12 ticks, so we scale it here reasonably.
-	y_ticks=1;
-	if (y_range > 10) y_ticks=2;
-	if (y_range > 20) y_ticks=6;
-	if (y_range > 40) y_ticks=12;
-	if (y_range > 80) y_ticks=24;
-	if (y_range > 200) y_ticks=48;
-	if (y_range > 400) y_ticks=100;
-	if (y_range > 800) y_ticks=250;
-	if (y_range > 1600) y_ticks=500;
-
-	double px;
-	fl_color(FL_BLACK);
-	fl_line_style(FL_SOLID,1);
-	char txt[64];
-	int r=0;
-	double txtw=0;
-	// Draw X gridlines every x_ticks yds and label them.
-	for (px=xmin;px<xmax;px+=((double)x_ticks*x_scale)){
-		//fl_line((int)px,y_bottom,(int)px,y_top);
-		fl_line_style(FL_DOT,1);
-		fl_line((int)px,(int)ymin,(int)px,(int)y0);
-		sprintf(txt,"%d",r*x_ticks);
-		if (r%2==0 && r>0) {
-			txtw=fl_width(txt);
-			fl_line_style(FL_SOLID,1);
-			fl_line((int)px,y0,(int)px,y0+8);
-			fl_draw(txt,(int)((int)px-(txtw/2)),y0+10+fl_height());
-		}
-		r++;
-	}
-	
-	// Draw Y hashmarks every 1 y_tick going up.
-	double py;
-	r=0;
-	for (py=y0;py>=ymin;py-=((double)y_ticks*y_scale)){
-		if (r>0){
-			fl_line(xmin,(int)py,xmax,(int)py);
-			sprintf(txt,"+%d ft-lb",r*y_ticks);
-			fl_draw(txt,xmin+10,(int)(py+fl_height()/2));
-		}
-		r++;
-	}
-	
-	
-	int x1,x2;
-	double y1,y2;
-	
-	// For the pixel locations to plot.
-	int px1, px2, py1,py2;
-	
-	x1=(int)this->gsln->GetRange(0);
-	y1=this->gsln->GetEnergy(0);
-		
-	int m=this->gsln->MaxRows();
-	
-	fl_color(FL_BLUE);
-	fl_line_style(FL_SOLID,1);
-	
-	for (int n=1;n<x_range && n<m ;n++){
-		x2=(int)this->gsln->GetRange(n);
-		y2=this->gsln->GetEnergy(n);
-		
-		// Translate the x,y values into scaled pixels.
-		px1=(int)(xmin+x_scale*(double)x1);
-		px2=(int)(xmin+x_scale*(double)x2);
-		
-		py1=(int)((y0)-(double)y_scale*(double)y1);
-		py2=(int)((y0)-(double)y_scale*(double)y2);
-	
-		if (py2>=ymax) break;
-		if (px2>=xmax) break;
-		
-		// Plot the points.
-		fl_line(px1,py1,px2,py2);
-		
-		x1=x2;
-		y1=y2;
-		
-
-	}
-	
-	
-	if (btMem1->value()==1){
-	
-		x1=(int)this->mem1->GetRange(0);
-		y1=this->mem1->GetEnergy(0);
-			
-		int m=this->mem1->MaxRows();
-		
-		fl_color(FL_RED);
-		fl_line_style(FL_SOLID,1);
-		
-		for (int n=1;n<x_range && n<m ;n++){
-			x2=(int)this->mem1->GetRange(n);
-			y2=this->mem1->GetEnergy(n);
-			
-			// Translate the x,y values into scaled pixels.
-			px1=(int)(xmin+x_scale*(double)x1);
-			px2=(int)(xmin+x_scale*(double)x2);
-			
-			py1=(int)((y0)-(double)y_scale*(double)y1);
-			py2=(int)((y0)-(double)y_scale*(double)y2);
-		
-			if (py2>=ymax) break;
-			if (px2>=xmax) break;
-			
-			// Plot the points.
-			if (px1>xmin && px1<xmax && py1<ymax && py1>ymin) fl_line(px1,py1,px2,py2);
-			
-			x1=x2;
-			y1=y2;
-			
-
-		}
-	}
-
-	
-	if (btMem2->value()==1){
-	
-		x1=(int)this->mem2->GetRange(0);
-		y1=this->mem2->GetEnergy(0);
-			
-		int m=this->mem2->MaxRows();
-		
-		fl_color(FL_GREEN);
-		fl_line_style(FL_SOLID,1);
-		
-		for (int n=1;n<x_range && n<m ;n++){
-			x2=(int)this->mem2->GetRange(n);
-			y2=this->mem2->GetEnergy(n);
-			
-			// Translate the x,y values into scaled pixels.
-			px1=(int)(xmin+x_scale*(double)x1);
-			px2=(int)(xmin+x_scale*(double)x2);
-			
-			py1=(int)((y0)-(double)y_scale*(double)y1);
-			py2=(int)((y0)-(double)y_scale*(double)y2);
-		
-			if (py2>=ymax) break;
-			if (px2>=xmax) break;
-			
-			// Plot the points.
-			if (px1>xmin && px1<xmax && py1<ymax && py1>ymin) fl_line(px1,py1,px2,py2);
-			
-			x1=x2;
-			y1=y2;
-			
-
-		}
-	}
-	
 	
-	if (x_click>xmin && x_click<xmax && y_click>ymin && y_click<ymax){
-		// If the user clicks, show the coordinates they clicked on.
-		double click_label_x= (x_click-xmin)/x_scale;
-		double click_label_y=(y0-y_click)/y_scale;
-		char lbl_point[20];
-		sprintf(lbl_point,"(%.0f,%.2f)",click_label_x, click_label_y);
-		fl_color(FL_BLACK);
-		fl_draw(lbl_point,x_click+5, y_click-5);
-		fl_rectf(x_click-2, y_click-2,4,4);
-	}
-	
-	
-	// Draw the frame around it last to make it all pretty.
-	fl_frame("aaaa",5,100,w-10,h-105);
-	
+	SetupPlot();
+	y0 = (ymax)-50;
+
+	DrawPlotBackground(PT_ENERGY, " ft-lbs");
+	DrawPlotData(PT_ENERGY);
+	
 	return;
-	
-
-
 }
 
-void PlotWindow::PlotVelocity(void){
-
-
-
-	int w = this->w();
-	int h = this->h();
-	
-	int xmin = 5;
-	int xmax = w-5;
-	int ymin = 100;
-	int ymax = h-5;
-	
-	int y0 = (ymax)-50;
-	
-	
-	// The gridlines look best with 15-25 graduations in x, so we set some basic defaults here.
-	x_ticks=25;
-	if (sl_x->value() > 500) x_ticks=50;
-	if (sl_x->value() > 1000) x_ticks=100;
-	if (sl_x->value() > 2000) x_ticks=250;
-	if (sl_x->value() > 4000) x_ticks=500;
-	
-
+void PlotWindow::PlotVelocity(int ptype){
+
 	// We need to find the max y-value to determine our y scale and y-ticks
 
 	double _maxy=0;
@@ -620,198 +561,19 @@
 		if (gsln->GetPath(e) > _maxy) _maxy=gsln->GetVelocity(e);
 	}
 
-	int x_range=(int)sl_x->value();
-	double y_range=0;
-	
-	if (fabs(_miny) > fabs(_maxy)) y_range = fabs(1.5*_miny);
-	else y_range = fabs(1.5*_maxy);
-	
-	double x_scale = (double)(xmax-xmin) / (double)x_range;
-	double y_scale = (double)(ymax-ymin) / (double)y_range;
-	
-	// Now do our custom drawing.
-	fl_draw_box(FL_FLAT_BOX,xmin,ymin,w-10,h-ymin-5,FL_WHITE);
-
-	
-	// Draw the x-axis.
-	fl_color(FL_BLACK);
-	fl_line_style(FL_SOLID,2);
-	fl_line(xmin,y0,xmax,y0);
-	
-	// The y-axis looks best with about 7-12 ticks, so we scale it here reasonably.
-	y_ticks=1;
-	if (y_range > 10) y_ticks=2;
-	if (y_range > 20) y_ticks=6;
-	if (y_range > 40) y_ticks=12;
-	if (y_range > 80) y_ticks=24;
-	if (y_range > 200) y_ticks=48;
-	if (y_range > 400) y_ticks=100;
-	if (y_range > 800) y_ticks=250;
-	if (y_range > 1600) y_ticks=500;
-
-	double px;
-	fl_color(FL_BLACK);
-	fl_line_style(FL_SOLID,1);
-	char txt[64];
-	int r=0;
-	double txtw=0;
-	// Draw X gridlines every x_ticks yds and label them.
-	for (px=xmin;px<xmax;px+=((double)x_ticks*x_scale)){
-		//fl_line((int)px,y_bottom,(int)px,y_top);
-		fl_line_style(FL_DOT,1);
-		fl_line((int)px,(int)ymin,(int)px,(int)y0);
-		sprintf(txt,"%d",r*x_ticks);
-		if (r%2==0 && r>0) {
-			txtw=fl_width(txt);
-			fl_line_style(FL_SOLID,1);
-			fl_line((int)px,y0,(int)px,y0+8);
-			fl_draw(txt,(int)((int)px-(txtw/2)),y0+10+fl_height());
-		}
-		r++;
-	}
-	
-	// Draw Y hashmarks every 1 y_tick going up.
-	double py;
-	r=0;
-	for (py=y0;py>=ymin;py-=((double)y_ticks*y_scale)){
-		if (r>0){
-			fl_line(xmin,(int)py,xmax,(int)py);
-			sprintf(txt,"+%d ft/s",r*y_ticks);
-			fl_draw(txt,xmin+10,(int)(py+fl_height()/2));
-		}
-		r++;
-	}
-	
-	
-	int x1,x2;
-	double y1,y2;
-	
-	// For the pixel locations to plot.
-	int px1, px2, py1,py2;
-	
-	x1=(int)this->gsln->GetRange(0);
-	y1=this->gsln->GetVelocity(0);
-		
-	int m=this->gsln->MaxRows();
-	
-	fl_color(FL_BLUE);
-	fl_line_style(FL_SOLID,1);
-	
-	for (int n=1;n<x_range && n<m ;n++){
-		x2=(int)this->gsln->GetRange(n);
-		y2=this->gsln->GetVelocity(n);
-		
-		// Translate the x,y values into scaled pixels.
-		px1=(int)(xmin+x_scale*(double)x1);
-		px2=(int)(xmin+x_scale*(double)x2);
-		
-		py1=(int)((y0)-(double)y_scale*(double)y1);
-		py2=(int)((y0)-(double)y_scale*(double)y2);
-	
-		if (py2>=ymax) break;
-		if (px2>=xmax) break;
-		
-		// Plot the points.
-		fl_line(px1,py1,px2,py2);
-		
-		x1=x2;
-		y1=y2;
-		
-
-	}
-	
-	if (btMem1->value()==1){
-		x1=(int)this->mem1->GetRange(0);
-		y1=this->mem1->GetVelocity(0);
-			
-		int m=this->mem1->MaxRows();
-		
-		fl_color(FL_RED);
-		fl_line_style(FL_SOLID,1);
-		
-		for (int n=1;n<x_range && n<m ;n++){
-			x2=(int)this->mem1->GetRange(n);
-			y2=this->mem1->GetVelocity(n);
-			
-			// Translate the x,y values into scaled pixels.
-			px1=(int)(xmin+x_scale*(double)x1);
-			px2=(int)(xmin+x_scale*(double)x2);
-			
-			py1=(int)((y0)-(double)y_scale*(double)y1);
-			py2=(int)((y0)-(double)y_scale*(double)y2);
-		
-			if (py2>=ymax) break;
-			if (px2>=xmax) break;
-			
-			// Plot the points.
-			if (px1>xmin && px1<xmax && py1<ymax && py1>ymin) fl_line(px1,py1,px2,py2);
-			
-			x1=x2;
-			y1=y2;
-			
-
-		}
-		
-	}
-	
-	
-	if (btMem2->value()==1){
-		x1=(int)this->mem2->GetRange(0);
-		y1=this->mem2->GetVelocity(0);
-			
-		int m=this->mem2->MaxRows();
-		
-		fl_color(FL_GREEN);
-		fl_line_style(FL_SOLID,1);
-		
-		for (int n=1;n<x_range && n<m ;n++){
-			x2=(int)this->mem2->GetRange(n);
-			y2=this->mem2->GetVelocity(n);
-			
-			// Translate the x,y values into scaled pixels.
-			px1=(int)(xmin+x_scale*(double)x1);
-			px2=(int)(xmin+x_scale*(double)x2);
-			
-			py1=(int)((y0)-(double)y_scale*(double)y1);
-			py2=(int)((y0)-(double)y_scale*(double)y2);
-		
-			if (py2>=ymax) break;
-			if (px2>=xmax) break;
-			
-			// Plot the points.
-			if (px1>xmin && px1<xmax && py1<ymax && py1>ymin) fl_line(px1,py1,px2,py2);
-			
-			x1=x2;
-			y1=y2;
-			
-
-		}
-		
-	}
-	
-	
-	if (x_click>xmin && x_click<xmax && y_click>ymin && y_click<ymax){
-		// If the user clicks, show the coordinates they clicked on.
-		double click_label_x= (x_click-xmin)/x_scale;
-		double click_label_y=(y0-y_click)/y_scale;
-		char lbl_point[20];
-		sprintf(lbl_point,"(%.0f,%.2f)",click_label_x, click_label_y);
-		fl_color(FL_BLACK);
-		fl_draw(lbl_point,x_click+5, y_click-5);
-		fl_rectf(x_click-2, y_click-2,4,4);
-	}
-	
-	
-	
-	
-	// Draw the frame around it last to make it all pretty.
-	fl_frame("aaaa",5,100,w-10,h-105);
-	
+	x_range=(int)sl_x->value();
+
+	if (fabs(_miny) > fabs(_maxy)) 
+	     y_range = fabs(1.5*_miny);
+	else y_range = fabs(1.5*_maxy);
+
+	SetupPlot();
+	y0 = (ymax)-50;
+
+	DrawPlotBackground(PT_VELOCITY, " ft/s");
+	DrawPlotData(ptype);
+
 	return;
-	
-	
-	
-	
 }
 
 void PlotWindow::cb_btPlot(Fl_Widget* o, void* v){
@@ -855,4 +617,19 @@
 	T->redraw();
 
 }
-	
+
+void PlotWindow::cb_Guides(Fl_Widget* o, void* v){
+
+	PlotWindow* T = (PlotWindow*)v;
+	T->redraw();
+
+}
+
+void PlotWindow::cb_PlotType(Fl_Widget* o, void* v){
+
+	PlotWindow* T = (PlotWindow*)v;
+	T->redraw();
+
+}
+
+
diff -x Makefile.in -x autom4te.cache -x configure -x aclocal.m4 -urN gebc-1.07/PlotWindow.h gebc-1.07-mike/PlotWindow.h
--- gebc-1.07/PlotWindow.h	2008-03-01 04:47:22.000000000 +0900
+++ gebc-1.07-mike/PlotWindow.h	2011-01-22 22:33:51.200065225 +0800
@@ -9,6 +9,7 @@
 #include <FL/fl_draw.h>
 #include <FL/Fl_Menu_Bar.H>
 #include <FL/Fl_Menu_Item.H>
+#include <FL/Fl_Choice.H>
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -18,11 +19,12 @@
 
 class PlotWindow : public Fl_Window {
 	public:
-	PlotWindow(int, int, GBCSolution*, GBCSolution*, GBCSolution*);
+	PlotWindow(int, int, GBCSolution*, GBCSolution*, GBCSolution*, GBCSolution*);
 	~PlotWindow(void);
 	GBCSolution* gsln;
 	GBCSolution* mem1;
 	GBCSolution* mem2;
+	GBCSolution* mem3;
 	
 
 	
@@ -32,22 +34,32 @@
 	int cheight;
 	int x_ticks;
 	int y_ticks;
-	
-	void PlotPath(void);
+	
+	int xmin, ymin, xmax, ymax;
+	int y0;
+	int x_range;
+	double y_range;
+	double x_scale, y_scale;
+	
+	void PlotMem(GBCSolution* mem, int mode);
+	void SetupPlot(void);
+	void DrawPlotBackground(int mode, const char *ylabel);
+	void DrawPlotData(int mode);
+	void PlotPath(int ptype);
 	void PlotEnergy(void);
-	void PlotVelocity(void);
+	void PlotVelocity(int ptype);
 	
 	int x_click;
 	int y_click;
-	
-	Fl_Round_Button* rbPlotPath;
-	Fl_Round_Button* rbPlotVelocity;
-	Fl_Round_Button* rbPlotEnergy;
 	
 	Fl_Check_Button* btMem1;
 	Fl_Check_Button* btMem2;
+	Fl_Check_Button* btMem3;
 	
 	Fl_Value_Slider* sl_x;
+	
+	Fl_Choice* cScopeGuides;
+	Fl_Choice* cPlotType;
 	
 	Fl_Menu_Bar* menu;
 	
@@ -58,6 +70,9 @@
 	static void cb_slUpdate(Fl_Widget* o, void* v);
 	static void cb_Mem1(Fl_Widget* o, void* v);
 	static void cb_Mem2(Fl_Widget* o, void* v);
+	static void cb_Mem3(Fl_Widget* o, void* v);
+	static void cb_Guides(Fl_Widget* o, void* v);
+	static void cb_PlotType(Fl_Widget* o, void* v);
 	
 
 };
diff -x Makefile.in -x autom4te.cache -x configure -x aclocal.m4 -urN gebc-1.07/RangeWindow.cpp gebc-1.07-mike/RangeWindow.cpp
--- gebc-1.07/RangeWindow.cpp	2008-03-01 04:47:22.000000000 +0900
+++ gebc-1.07-mike/RangeWindow.cpp	2010-11-01 22:14:43.217693872 +0800
@@ -1,5 +1,8 @@
 #include "RangeWindow.h"
 
+#define MOAtoMIL(moa) (moa/3.438)
+#define MILtoMOA(mil) (mil*3.438)
+
 RangeWindow::RangeWindow(int w, int h, GBCSolution* inSLN):Fl_Window(w,h,inSLN->Name()){
 	begin();
 	menu = new Fl_Menu_Bar(0,0,w,30,"MENU");
@@ -55,16 +58,19 @@
 	tbl = new Fl_Browser(5,35,w-10,h-40,"Hello");	
 
 	
-	colwidths = (int*)malloc(10*sizeof(int));
+	colwidths = (int*)malloc(12*sizeof(int));
 	colwidths[0]=70; // Range (yds)
 	colwidths[1]=70; // Drop (in)
 	colwidths[2]=70; // Drop (MOA)
-	colwidths[3]=70; // Vel (ft/s)
-	colwidths[4]=70; // Energy (ft-lb)
-	colwidths[5]=70; // Winddrift (in)
-	colwidths[6]=70; // Windage (ft)
-	colwidths[7]=70; // Time (s)
-	colwidths[8]=0;	
+	colwidths[3]=70; // Drop (MIL)
+	colwidths[4]=70; // Target Size (MILs)
+	colwidths[5]=70; // Vel (ft/s)
+	colwidths[6]=70; // Energy (ft-lb)
+	colwidths[7]=70; // Winddrift (in)
+	colwidths[8]=70; // Windage (ft)
+	colwidths[9]=70; // Windage (MIL)
+	colwidths[10]=70; // Time (s)
+	colwidths[11]=0;	
 	
 	tbl->column_widths(colwidths);
 	tbl->column_char('\t');
@@ -72,6 +78,7 @@
 	min=0;
 	max=1000;
 	step=10;
+	targetsize=4.0; // inches
 	
 	GenTable();
 		
@@ -88,21 +95,116 @@
 
 }
 
+
+
+/*
+   Mini-HOWTO: modifying the range table.
+   
+   For the table data:
+           - update COLUMNS define, headers0, headers1, format, 
+             sqlnames and xmlnames arrays below.
+           - add a case to GetData for the column data
+   For the load data at the top:
+           - modify GetPreface() and GetPrefaceLines()
+
+   Note: entries with a blank sqlname are not written to the sql output.
+         entries with a blank xmlname are not written to the xml output.
+*/
+
+#define COLUMNS 11
+static const char *headers0[COLUMNS]={"Range",  "Drop",    "Drop",     "Drop",    "4\" Obj", "Velocity","Energy",  "Wind Drift","Windage",    "Windage",    "Time"};
+static const char *headers1[COLUMNS]={"(yards)","(inches)","(MOA)",    "(MIL)",   "(MIL)",   "(ft/s)",  "(ft-lbs)","(inches)",  "(MOA)",      "(MIL)",      "(s)" };
+static const char *format  [COLUMNS]={"%.0f",   "%.2f",    "%.2f",     "%.2f",    "%.2f",    "%.0f",    "%.0f",    "%.2f",      "%.2f",       "%.2f",       "%.2f"};
+static const char *sqlnames[COLUMNS]={"range",  "drop",    "elev_moa", "elev_mil","",        "velocity","energy",  "winddrift", "windage_moa","windage_mil","time"};
+static const char *xmlnames[COLUMNS]={"Range",  "Drop",    "ElevMOA",  "ElevMIL", "",        "Velocity","Energy",  "WindDrift", "WindageMOA", "WindageMIL", "Time"};
+
+int RangeWindow::GetColumns(void){
+  return COLUMNS;
+}
+
+int RangeWindow::GetHeaderLines(void){
+  return 2;
+}
+
+
+int RangeWindow::GetPrefaceLines(void){
+  return 5;
+}
+
+void RangeWindow::GetPreface(int l, char *str){
+    switch (l) {
+          case 0: sprintf(str,"Drag Coefficient: %.3f   Projectile Weight: %d grains",Sln->BC(), Sln->Weight());
+                  break;
+          case 1: sprintf(str,"Initial Velocity: %d (ft/s)   Zero Range: %d yards  (%d metres) Shooting Angle: %d degrees",Sln->MuzzleVelocity(), Sln->ZeroRange(), (int)(Sln->ZeroRange()*0.9144), Sln->ShootingAngle());
+                  break;
+          case 2: sprintf(str,"Wind Velocity:  %d mph (%1.1f m/sec)   Wind Direction: %d degrees",Sln->WindSpeed(), Sln->WindSpeed()*0.44704, Sln->WindAngle());
+                  break;
+          case 3: sprintf(str,"Altitude: %d feet (%1.0f M)  Barometer: %.2f in-Hg (%1.0f mbar)",
+	                  Sln->Altitude(), Sln->Altitude() * 0.3048,
+	                  Sln->Pressure(), Sln->Pressure() * 33.8639);
+	          break;
+          case 4: sprintf(str,"Temperature: %d F (%1.0f C)  Relative Humidity: %d%%",
+	          Sln->Temp(), 100.0/(212-32) * (Sln->Temp() - 32),
+	          Sln->Humidity());
+	          break;
+         default: *str='\0';
+                  break;
+    }
+}
+
+const char *RangeWindow::GetHeader(int col, int row){
+  if (col<0 || col>=GetColumns()) return NULL;
+  if (row==0) return headers0[col];
+  if (row==1) return headers1[col];
+  return NULL;
+}
+
+/* returns the data for a column at a given range */
+int RangeWindow::GetData(int col, int range, char *buf){
+  if (col>=GetColumns()) { *buf='\0'; return 0; }
+  if (range<0)           { *buf='\0'; return 0; }
+  
+  if (range==0 && 
+      (col==2 || col==3 || col==4 || col==8 || col==9)
+     ) return sprintf(buf, "-");
+  
+  double v=0;
+  switch (col) {
+      case 0: v= Sln->GetRange(range);				break;
+      case 1: v= Sln->GetPath(range);				break;
+      case 2: v= Sln->GetMOA(range);				break;
+      case 3: v= MOAtoMIL(Sln->GetMOA(range));			break;
+      case 4: v= (targetsize / 36.0 * 1000) / range;		break;
+      case 5: v= Sln->GetVelocity(range);			break;
+      case 6: v= Sln->GetVelocity(range);
+              v= Sln->Weight()*v*v/450436;
+              break;
+      case 7: v= Sln->GetWindage(range);			break;
+      case 8: v= Sln->GetWindageMOA(range);			break;
+      case 9: v= MOAtoMIL(Sln->GetWindageMOA(range));		break;
+      case 10:v= Sln->GetTime(range);				break;
+      }
+      
+  return sprintf(buf, format[col], v);
+}
+
+static char buffer[20];
+char *RangeWindow::GetData(int col, int range){
+  GetData(col, range, buffer);
+  return buffer;
+}
+
 
 void RangeWindow::GenTable(){
 	
 	
-	double r,p,m,v,e,wi,wm,t;
 	tbl->clear();
 	
 	int MIN=this->min;
 	int MAX=this->max;
 	int STEP=this->step;
-
-		
-
+	
 	int num=Sln->MaxRows();
-	
 
 	// printf("NUM: %d",num);
 
@@ -110,34 +212,43 @@
 	if (MIN>MAX) MIN=MAX;
 	
 	char* str = (char*)malloc(1024*sizeof(char));
+	char* strp;
 	
 	// Print some general information about the load.
-	sprintf(str,"@b%s",Sln->Name()); tbl->add(str);
-	sprintf(str,"Drag Coefficient: %.3f   Projectile Weight: %d grains",Sln->BC(), Sln->Weight()); tbl->add(str);
-	sprintf(str,"Initial Velocity: %d (ft/s)   Zero Range: %d yards   Shooting Angle: %d degrees",Sln->MuzzleVelocity(), Sln->ZeroRange(), Sln->ShootingAngle()); tbl->add(str);
-	sprintf(str,"Wind Velocity:  %d mph    Wind Direction: %d degrees",Sln->WindSpeed(), Sln->WindAngle()); tbl->add(str);
-	sprintf(str,"Altitude: %d feet   Barometer: %.2f in-Hg  Temperature: %d F   Relative Humidity: %d%%",Sln->Altitude(), Sln->Pressure(), Sln->Temp(), Sln->Humidity()); tbl->add(str);
+	sprintf(str, "@b%s", Sln->Name());
+	tbl->add(str);
+
+        for (int n=0; n < GetPrefaceLines(); n++) {
+            GetPreface(n, str);
+            tbl->add(str);
+        }
 	
 	tbl->add("");
 	
-	tbl->add("@b@cRange\t@b@cDrop\t@b@cDrop\t@b@cVelocity\t@b@cEnergy\t@b@cWind Drift\t@b@cWindage\t@b@cTime",0);
-	tbl->add("@c(yards)\t@c(inches)\t@c(MOA)\t@c(ft/s)\t@c(ft-lb)\t@c(inches)\t@c(MOA)\t@c(s)",0);
-		
-	for (int n=MIN;n<=MAX;n=n+STEP){
-		r=Sln->GetRange(n);
-		p=Sln->GetPath(n);
-		m=Sln->GetMOA(n);
-		v=Sln->GetVelocity(n);
-		wi=Sln->GetWindage(n);
-		wm=Sln->GetWindageMOA(n);
-		t=Sln->GetTime(n);
-		e=Sln->Weight()*v*v/450436;
-		
-		sprintf(str,"@c%.0f\t@c%.2f\t@c%.2f\t@c%.0f\t@c%.0f\t@c%.2f\t@c%.2f\t@c%.2f",r,p,m,v,e,wi,wm,t);
-		tbl->add(str,0);
-	}
-	
+	
+	// headers
+	for (int hline=0; hline < GetHeaderLines(); hline++) {
+	    int col;
+	    strp=str;
+            for (col=0; col < GetColumns()-1; col++) {
+                strp+=sprintf(strp, "@b@c%s\t", GetHeader(col, hline));
+                }
+            sprintf(strp, "@b@c%s", GetHeader(col,hline));
+            tbl->add(str);
+        }
+            
+        // actual data
+	for (int n=MIN;n<=MAX;n=n+STEP){
+	    int col;
+	    strp=str;
+	    for (col=0; col < GetColumns()-1; col++) {
+	        strp+=sprintf(strp, "@c%s\t", GetData(col, n));
+	        }
+            sprintf(strp, "@c%s", GetData(col,n));
+            tbl->add(str,0);
+	}
 	
+	free(str);
 }
 
 
@@ -282,32 +393,31 @@
 	FILE* ofile = fopen(fname,"w");
 	
 	// Print the output to a file.
-	double r,p,m,v,e,wi,wm,t;
 	
 	int MIN=T->min;
 	int MAX=T->max;
 	int STEP=T->step;
 
-	fprintf(ofile, "Range,Drop,Drop,Velocity,Energy,Wind Drift,Windage,Time");
-	fprintf(ofile, "\n(yards),(inches),(MOA),(ft/s),(ft-lb),(inches),(MOA),(s)");
+	// headers
+	for (int hline=0; hline < T->GetHeaderLines(); hline++) {
+	    int col;
+            for (col=0; col < T->GetColumns()-1; col++) {
+                fprintf(ofile, "%s,", T->GetHeader(col,hline));
+            }
+            fprintf(ofile,"%s\n", T->GetHeader(col,hline));
+        }
 	
 	int num=T->Sln->MaxRows();
 	if (MAX>num) MAX=num;
 	if (MIN>MAX) MIN=MAX;
 	
+	// actual data
 	for (int n=MIN;n<=MAX;n=n+STEP){
-		r=T->Sln->GetRange(n);
-		p=T->Sln->GetPath(n);
-		m=T->Sln->GetMOA(n);
-		v=T->Sln->GetVelocity(n);
-		e=0;
-		wi=T->Sln->GetWindage(n);
-		wm=T->Sln->GetWindageMOA(n);
-		t=T->Sln->GetTime(n);
-		e=T->Sln->Weight()*v*v/450436;
-		
-		fprintf(ofile,"\n%.0f,%.2f,%.2f,%.0f,%.2f,%.2f,%.2f,%.2f",r,p,m,v,e,wi,wm,t);
-		
+		int col;
+		for (col=0; col < T->GetColumns()-1; col++) {
+		    fprintf(ofile, "%s,", T->GetData(col, n));
+                }
+                fprintf(ofile,"%s\n", T->GetData(col, n));
 	}
 	
 	fclose(ofile);
@@ -325,69 +435,39 @@
 	FILE* ofile = fopen(fname,"w");
 	
 	// Print the output to a file.
-	double r,p,m,v,e,wi,wm,t;
 	
 	int MIN=T->min;
 	int MAX=T->max;
 	int STEP=T->step;
 
-	fprintf(ofile, "\n<html><head><title>$s</title></head>");
-	fprintf(ofile, "\n\n<table><tr>");
-	fprintf(ofile, "<td>Range</td>\
-					<td>Drop</td>\
-					<td>Drop</td>\
-					<td>Velocity</td>\
-					<td>Energy</td>\
-					<td>Winddrift</td>\
-					<td>Windage</td>\
-					<td>Time</td></tr>"
-					);
-					
-	fprintf(ofile,"\n<tr>");
-	fprintf(ofile, "<td>(yards)</td>\
-					<td>(inches)</td>\
-					<td>(MOA)</td>\
-					<td>(ft/s)</td>\
-					<td>(ft-lb)</td>\
-					<td>(inches)</td>\
-					<td>(MOA)</td>\
-					<td>(s)</td>"
-					);
-					
+	fprintf(ofile, "\n<html><head><title>%s</title></head>", T->Sln->Name());
+	fprintf(ofile, "\n\n<table>");
+
+	// headers
+	for (int hline=0; hline < T->GetHeaderLines(); hline++) {
+	    int col;
+	    fprintf(ofile, "<tr>");
+            for (col=0; col < T->GetColumns()-1; col++) {
+                fprintf(ofile, "<td>%s</td>", T->GetHeader(col,hline));
+            }
+            fprintf(ofile,"<td>%s</td></tr>\n", T->GetHeader(col,hline));
+        }
+	
 	int num=T->Sln->MaxRows();
 	if (MAX>num) MAX=num;
 	if (MIN>MAX) MIN=MAX;
 		
 	for (int n=MIN;n<=MAX;n=n+STEP){
-		r=T->Sln->GetRange(n);
-		p=T->Sln->GetPath(n);
-		m=T->Sln->GetMOA(n);
-		v=T->Sln->GetVelocity(n);
-		e=0;
-		wi=T->Sln->GetWindage(n);
-		wm=T->Sln->GetWindageMOA(n);
-		t=T->Sln->GetTime(n);
-		e=T->Sln->Weight()*v*v/450436;
-		
-		fprintf(ofile,"\n<tr>\
-						<td>%.0f</td>\
-						<td>%.2f</td>\
-						<td>%.2f</td>\
-						<td>%.0f</td>\
-						<td>%.2f</td>\
-						<td>%.2f</td>\
-						<td>%.2f</td>\
-						<td>%.2f</td></tr>",
-						r,p,m,v,e,wi,wm,t);
+		int col;
+		fprintf(ofile, "<tr>");
+		for (col=0; col < T->GetColumns()-1; col++) {
+		    fprintf(ofile, "<td>%s</td>", T->GetData(col, n));
+                }
+                fprintf(ofile,"<td>%s</td></tr>\n", T->GetData(col, n));
 	}
 	
 	fprintf(ofile,"\n</table></html>");
 	fclose(ofile);
-
-
-
-	
-	
 }
 
 
@@ -403,66 +483,39 @@
 	FILE* ofile = fopen(fname,"w");
 	
 	// Print the output to a file.
-	double r,p,m,v,e,wi,wm,t;
-	
 	int MIN=T->min;
 	int MAX=T->max;
 	int STEP=T->step;
-
-	fprintf(ofile, "\n<html><head><title>%s</title></head>","TO DO ");
-	fprintf(ofile, "\n\n<table><tr>");
-	fprintf(ofile, "\n<td>Range</td>\
-					\n<td>Drop</td>\
-					\n<td>Drop</td>\
-					\n<td>Velocity</td>\
-					\n<td>Energy</td>\
-					\n<td>Winddrift</td>\
-					\n<td>Windage</td>\
-					\n<td>Time</td></tr>"
-					);
-					
-	fprintf(ofile,"\n\n<tr>");
-	fprintf(ofile, "\n<td>(yards)</td>\
-					\n<td>(inches)</td>\
-					\n<td>(MOA)</td>\
-					\n<td>(ft/s)</td>\
-					\n<td>(ft-lb)</td>\
-					\n<td>(inches)</td>\
-					\n<td>(MOA)</td>\
-					\n<td>(s)</td>"
-					);
-					
+
+	fprintf(ofile, "\n<html><head><title>%s</title></head>", T->Sln->Name());
+	fprintf(ofile, "\n\n<table>");
+
+	// headers
+	for (int hline=0; hline < T->GetHeaderLines(); hline++) {
+	    int col;
+	    fprintf(ofile, "<tr>");
+            for (col=0; col < T->GetColumns()-1; col++) {
+                fprintf(ofile, "<td>%s</td>", T->GetHeader(col,hline));
+            }
+            fprintf(ofile,"<td>%s</td></tr>\n", T->GetHeader(col,hline));
+        }
+
 	int num=T->Sln->MaxRows();
 	if (MAX>num) MAX=num;
 	if (MIN>MAX) MIN=MAX;
 	
 
 	for (int n=MIN;n<=MAX;n=n+STEP){
-		r=T->Sln->GetRange(n);
-		p=T->Sln->GetPath(n);
-		m=T->Sln->GetMOA(n);
-		v=T->Sln->GetVelocity(n);
-		e=0;
-		wi=T->Sln->GetWindage(n);
-		wm=T->Sln->GetWindageMOA(n);
-		t=T->Sln->GetTime(n);
-		e=T->Sln->Weight()*v*v/450436;
-		
-		fprintf(ofile,"\n<tr>\
-						\n<td>%.0f</td>\
-						\n<td>%.2f</td>\
-						\n<td>%.2f</td>\
-						\n<td>%.0f</td>\
-						\n<td>%.2f</td>\
-						\n<td>%.2f</td>\
-						\n<td>%.2f</td>\
-						\n<td>%.2f</td></tr>",
-						r,p,m,v,e,wi,wm,t);
+		int col;
+		fprintf(ofile, "<tr>");
+		for (col=0; col < T->GetColumns()-1; col++) {
+		    fprintf(ofile, "<td>%s</td>", T->GetData(col, n));
+                }
+                fprintf(ofile,"<td>%s</td></tr>\n", T->GetData(col, n));
 	}
 	
 	fprintf(ofile,"\n</table></html>");
 	fclose(ofile);
-	
 }
 
 
@@ -477,70 +530,42 @@
 	FILE* ofile = fopen(fname,"w");
 	
 	// Print the output to a file.
-	double r,p,m,v,e,wi,wm,t;
 	
 	int MIN=T->min;
 	int MAX=T->max;
 	int STEP=T->step;
 
 	
-	fprintf(ofile, "\n<html><head><title>%s</title></head>","");
-	fprintf(ofile, "\n\n<table width=560 bgcolor=black><tr>");
-	fprintf(ofile, "\n<td width=70 bgcolor=white align=center><b>Range</b></td>\
-					\n<td width=70 bgcolor=white align=center><b>Drop</b></td>\
-					\n<td width=70 bgcolor=white align=center><b>Drop</b></td>\
-					\n<td width=70 bgcolor=white align=center><b>Velocity</b></td>\
-					\n<td width=70 bgcolor=white align=center><b>Energy</b></td>\
-					\n<td width=70 bgcolor=white align=center><b>Winddrift</b></td>\
-					\n<td width=70 bgcolor=white align=center><b>Windage</b></td>\
-					\n<td width=70 bgcolor=white align=center><b>Time</b></td></tr>"
-					);
-					
-	fprintf(ofile,"\n\n<tr>");
-	fprintf(ofile, "\n<td width=70 bgcolor=white  align=center><b>(yards)</b></td>\
-					\n<td width=70 bgcolor=white align=center><b>(inches)</b></td>\
-					\n<td width=70 bgcolor=white align=center><b>(MOA)</b></td>\
-					\n<td width=70 bgcolor=white align=center><b>(ft/s)</b></td>\
-					\n<td width=70 bgcolor=white align=center><b>(ft-lb)</b></td>\
-					\n<td width=70 bgcolor=white align=center><b>(inches)</b></td>\
-					\n<td width=70 bgcolor=white align=center><b>(MOA)</b></td>\
-					\n<td width=70 bgcolor=white align=center><b>(s)</b></td>"
-					);
-					
+	fprintf(ofile, "\n<html><head><title>%s</title></head>",T->Sln->Name());
+	fprintf(ofile, "\n\n<table width=560 bgcolor=black>");
+	
+	// headers
+	for (int hline=0; hline < T->GetHeaderLines(); hline++) {
+	    int col;
+	    fprintf(ofile, "<tr>\n");
+            for (col=0; col < T->GetColumns()-1; col++) {
+                fprintf(ofile, "\t<td width=70 bgcolor=white align=center><b>%s</b></td>", T->GetHeader(col,hline));
+            }
+            fprintf(ofile,"\t<td width=70 bgcolor=white align=center>%s</b></td>\n</tr>\n", T->GetHeader(col,hline));
+        }
+	
 	int num=T->Sln->MaxRows();
 	if (MAX>num) MAX=num;
 	if (MIN>MAX) MIN=MAX;
 	
 	for (int n=MIN;n<=MAX;n=n+STEP){
-		r=T->Sln->GetRange(n);
-		p=T->Sln->GetPath(n);
-		m=T->Sln->GetMOA(n);
-		v=T->Sln->GetVelocity(n);
-		e=0;
-		wi=T->Sln->GetWindage(n);
-		wm=T->Sln->GetWindageMOA(n);
-		t=T->Sln->GetTime(n);
-		e=T->Sln->Weight()*v*v/450436;
-		
-		e=v*v/450436;
-		
-		fprintf(ofile,"\n\n<tr>\
-						\n<td width=70 bgcolor=white align=center>%.0f</td>\
-						\n<td width=70 bgcolor=white align=center>%.2f</td>\
-						\n<td width=70 bgcolor=white align=center>%.2f</td>\
-						\n<td width=70 bgcolor=white align=center>%.0f</td>\
-						\n<td width=70 bgcolor=white align=center>%.2f</td>\
-						\n<td width=70 bgcolor=white align=center>%.2f</td>\
-						\n<td width=70 bgcolor=white align=center>%.2f</td>\
-						\n<td width=70 bgcolor=white align=center>%.2f</td></tr>",
-						r,p,m,v,e,wi,wm,t);
+		int col;
+		fprintf(ofile, "<tr>");
+		for (col=0; col < T->GetColumns()-1; col++) {
+		    fprintf(ofile, "\t<td width=70 bgcolor=white align=center>%s</td>", T->GetData(col, n));
+                }
+                fprintf(ofile,"\t<td width=70 bgcolor=white align=center>%s</td>\n</tr>\n", T->GetData(col, n));
 	}
 	
 	fprintf(ofile,"\n</table></html>");
 	fclose(ofile);
-
-
 }
+
 void RangeWindow::cb_ExportSQL(Fl_Widget* f, void* vtt){
 
 	RangeWindow* T = (RangeWindow*)vtt;
@@ -552,7 +577,6 @@
 	FILE* ofile = fopen(fname,"w");
 	
 	// Print the output to a file.
-	double r,p,m,v,e,wi,wm,t;
 	
 	int MIN=T->min;
 	int MAX=T->max;
@@ -561,37 +585,36 @@
 	int num=T->Sln->MaxRows();
 	if (MAX>num) MAX=num;
 	if (MIN>MAX) MIN=MAX;
-			
+
+	char* str = (char*)malloc(1024*sizeof(char));
+	char* strp;
+
+        // The column names are in their own array. Columns with blank sql names are
+        // not written to the output.	
+	for (int hline=0; hline < T->GetHeaderLines(); hline++) {
+	    int col;
+	    strp=str;
+            for (col=0; col < T->GetColumns()-1; col++) {
+                if (sqlnames[col] && *sqlnames[col])
+                   strp+=sprintf(strp, "%s,", sqlnames[col]);
+            }
+            sprintf(strp, "%s", sqlnames[col]);
+        }
+
 	for (int n=MIN;n<=MAX;n=n+STEP){
-		r=T->Sln->GetRange(n);
-		p=T->Sln->GetPath(n);
-		m=T->Sln->GetMOA(n);
-		v=T->Sln->GetVelocity(n);
-		e=0;
-		wi=T->Sln->GetWindage(n);
-		wm=T->Sln->GetWindageMOA(n);
-		t=T->Sln->GetTime(n);
-		e=T->Sln->Weight()*v*v/450436;
-
-		fprintf(ofile,"\nINSERT INTO BallisticData {range, drop, elevation, velocity, energy, winddrift, windage, time} VALUES\
-						{%.0f,\
-						%.2f, \
-						%.2f,\
-						%.0f,\
-						%.2f,\
-						%.2f,\
-						%.2f,\
-						%.2f};",
-						r,p,m,v,e,wi,wm,t);
+		int col;
+		fprintf(ofile, "INSERT INTO BallisticData (%s) VALUES (", str);
+		for (col=0; col < T->GetColumns()-1; col++) {
+		    if (sqlnames[col] && *sqlnames[col])
+		       fprintf(ofile, "%s,", T->GetData(col, n));
+                }
+                fprintf(ofile,"%s);\n", T->GetData(col, n));
 	}
 	
-	
-	
+	free(str);
 	fclose(ofile);
-	
-
-
 }
+
 void RangeWindow::cb_ExportXML(Fl_Widget* f, void* vtt){
 
 
@@ -604,7 +627,6 @@
 	FILE* ofile = fopen(fname,"w");
 	
 	// Print the output to a file.
-	double r,p,m,v,e,wi,wm,t;
 	
 	int MIN=T->min;
 	int MAX=T->max;
@@ -613,44 +635,30 @@
 	fprintf(ofile, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
 	
 
-	fprintf(ofile, "\n<SolutionTitle>%s</SolutionTitle>","TEST");
+	fprintf(ofile, "\n<SolutionTitle>%s</SolutionTitle>",T->Sln->Name());
 	fprintf(ofile, "\n\n<SolutionData>");
 					
 	int num=T->Sln->MaxRows();
 	if (MAX>num) MAX=num;
 	if (MIN>MAX) MIN=MAX;
-		
+
 	for (int n=MIN;n<=MAX;n=n+STEP){
-		r=T->Sln->GetRange(n);
-		p=T->Sln->GetPath(n);
-		m=T->Sln->GetMOA(n);
-		v=T->Sln->GetVelocity(n);
-		e=0;
-		wi=T->Sln->GetWindage(n);
-		wm=T->Sln->GetWindageMOA(n);
-		t=T->Sln->GetTime(n);
-		e=T->Sln->Weight()*v*v/450436;
-
-		fprintf(ofile,"\n<SolutionElement>\
-						<Range>%.0f</Range>\
-						<Drop>%.2f</Drop>\
-						<Elevation>%.2f</Elevation>\
-						<Velocity>%.0f</Velocity>\
-						<Energy>%.2f</Energy>\
-						<Winddrift>%.2f</Winddrift>\
-						<Windage>%.2f</Windage>\
-						<Time>%.2f</td></Time></SolutionElement>",
-						r,p,m,v,e,wi,wm,t);
+		fprintf(ofile,"\n<SolutionElement>\n");
+		int col;
+		for (col=0; col < T->GetColumns(); col++) {
+		    if (xmlnames[col] && *xmlnames[col])
+		       fprintf(ofile, "\t<%s>%s</%s>\n", xmlnames[col], T->GetData(col, n), xmlnames[col]);
+                }
+		fprintf(ofile,"</SolutionElement>\n");
 	}
 	
 	fprintf(ofile,"\n</SolutionData>");
 	
 	
 	fclose(ofile);
-	
-	
 }
 
+
 void RangeWindow::cb_Close(Fl_Widget* f, void* v){
 	RangeWindow* T = (RangeWindow*)v;
 	T->~RangeWindow();
@@ -663,7 +671,7 @@
 	RangeWindow* T = (RangeWindow*)vtt;
 	
 	char* fname=NULL;
-	fname = fl_file_chooser("Please select a location and filename to save the PDF Document.","*.pdf","OutputData.pdf ",0);
+	fname = fl_file_chooser("Please select a location and filename to save the PDF Document.","*.pdf","OutputData.pdf",0);
 	if (fname==NULL) return;
 
 
@@ -698,9 +706,10 @@
 
     /* output Row Data. */
 	int margin=50;
-	int colsize=62;
+	int colsize=45;
 	int rowheight=10;
 	int footer=50;
+	int row=0;
 		
 	HPDF_Page_SetFontAndSize (page, def_font, 10);
     HPDF_Page_BeginText (page);
@@ -708,68 +717,39 @@
 	// First print the weather condition data and such.
 	char* str = (char*)malloc(1024*sizeof(char));
 	// Print some general information about the load.
-	sprintf(str,"Drag Coefficient: %.3f   Projectile Weight: %d grains",T->Sln->BC(), T->Sln->Weight());
-	HPDF_Page_TextOut (page,margin+0*colsize, height - 80 - rowheight*0, str);
-	sprintf(str,"Initial Velocity: %d (ft/s)   Zero Range: %d yards   Shooting Angle: %d degrees",T->Sln->MuzzleVelocity(), T->Sln->ZeroRange(), T->Sln->ShootingAngle());
-	HPDF_Page_TextOut (page,margin+0*colsize, height - 80 - rowheight*1, str);
-	sprintf(str,"Wind Velocity:  %d mph    Wind Direction: %d degrees",T->Sln->WindSpeed(), T->Sln->WindAngle());
-	HPDF_Page_TextOut (page,margin+0*colsize, height - 80 - rowheight*2, str);
-	sprintf(str,"Altitude: %d feet   Barometer: %.2f in-Hg  Temperature: %d F   Relative Humidity: %d%%",T->Sln->Altitude(), T->Sln->Pressure(), T->Sln->Temp(), T->Sln->Humidity());
-	HPDF_Page_TextOut (page,margin+0*colsize, height - 80 - rowheight*3, str);
-
-	
-    HPDF_Page_TextOut (page,margin+0*colsize, height - 80 - rowheight*5, "Range");
-	HPDF_Page_TextOut(page,margin+1*colsize,height-80- rowheight*5, "Drop");
-	HPDF_Page_TextOut(page,margin+2*colsize,height-80- rowheight*5,"Elevation");
-	HPDF_Page_TextOut(page,margin+3*colsize,height-80- rowheight*5,"Velocity");
-	HPDF_Page_TextOut(page,margin+4*colsize,height-80- rowheight*5,"Energy");
-	HPDF_Page_TextOut(page,margin+5*colsize,height-80- rowheight*5,"Wind Drift");
-	HPDF_Page_TextOut(page,margin+6*colsize,height-80- rowheight*5,"Windage");
-	HPDF_Page_TextOut(page,margin+7*colsize,height-80- rowheight*5,"Time");
-	
-	HPDF_Page_TextOut (page,margin+0*colsize, height - 80 - rowheight*6, "(yards)");
-	HPDF_Page_TextOut(page,margin+1*colsize,height-80- rowheight*6, "(inches)");
-	HPDF_Page_TextOut(page,margin+2*colsize,height-80- rowheight*6,"(MOA)");
-	HPDF_Page_TextOut(page,margin+3*colsize,height-80- rowheight*6,"(ft/s)");
-	HPDF_Page_TextOut(page,margin+4*colsize,height-80- rowheight*6,"(ft-lb)");
-	HPDF_Page_TextOut(page,margin+5*colsize,height-80- rowheight*6,"(inches)");
-	HPDF_Page_TextOut(page,margin+6*colsize,height-80- rowheight*6,"(MOA)");
-	HPDF_Page_TextOut(page,margin+7*colsize,height-80- rowheight*6,"(seconds)");
-	
-	
+        for (int n=0; n < T->GetPrefaceLines(); n++) {
+            T->GetPreface(n, str);
+	    HPDF_Page_TextOut (page,margin+0*colsize, height - 80 - rowheight*row, str);
+	    row++;
+        }
+	row++;
+	
+	// headers
+	for (int hline=0; hline < T->GetHeaderLines(); hline++) {
+	    int col;
+            for (col=0; col < T->GetColumns(); col++) {
+                HPDF_Page_TextOut(page,margin+col*colsize, height-80-rowheight*row, T->GetHeader(col,hline));
+            }
+            row++;
+        }
+        row++;
+            
     HPDF_Page_EndText (page);
 
 
 
 	// Print the rows iteratively
-	double r,p,m,v,e,wi,wm,t;
 	int MIN=T->min;
 	int MAX=T->max;
 	int STEP=T->step;
-	int row=8;
 	HPDF_Page_SetFontAndSize (page, def_font, 8);
 	
 	for (int n=MIN;n<=MAX;n=n+STEP){
-		r=T->Sln->GetRange(n);
-		p=T->Sln->GetPath(n);
-		m=T->Sln->GetMOA(n);
-		v=T->Sln->GetVelocity(n);
-		e=0;
-		wi=T->Sln->GetWindage(n);
-		wm=T->Sln->GetWindageMOA(n);
-		t=T->Sln->GetTime(n);
-		e=T->Sln->Weight()*v*v/450436;
-
 		// Print the row.
 		HPDF_Page_BeginText (page);
-		sprintf(str,"%.0f",r);	HPDF_Page_TextOut (page,margin+0*colsize, height - 80 - rowheight*row,str);
-		sprintf(str,"%.2f",p);	HPDF_Page_TextOut (page,margin+1*colsize, height - 80 - rowheight*row,str);
-		sprintf(str,"%.2f",m);	HPDF_Page_TextOut (page,margin+2*colsize, height - 80 - rowheight*row,str);
-		sprintf(str,"%.0f",v);	HPDF_Page_TextOut (page,margin+3*colsize, height - 80 - rowheight*row,str);
-		sprintf(str,"%.0f",e);	HPDF_Page_TextOut (page,margin+4*colsize, height - 80 - rowheight*row,str);
-		sprintf(str,"%.2f",wi);	HPDF_Page_TextOut (page,margin+5*colsize, height - 80 - rowheight*row,str);
-		sprintf(str,"%.2f",wm);	HPDF_Page_TextOut (page,margin+6*colsize, height - 80 - rowheight*row,str);
-		sprintf(str,"%.2f",t);	HPDF_Page_TextOut (page,margin+7*colsize, height - 80 - rowheight*row,str);
+		for (int col=0; col < T->GetColumns(); col++) {
+		    HPDF_Page_TextOut(page,margin+col*colsize, height - 80 - rowheight*row, T->GetData(col, n));
+                }
 		HPDF_Page_EndText (page);
 		row++;
 		
@@ -779,28 +759,19 @@
 			page = HPDF_AddPage (pdf);
 			HPDF_Page_SetFontAndSize (page, def_font, 10);
 			HPDF_Page_BeginText (page);
-			HPDF_Page_TextOut (page,margin+0*colsize, height - 80 - rowheight*2, "Range");
-			HPDF_Page_TextOut(page,margin+1*colsize,height-80- rowheight*2, "Drop");
-			HPDF_Page_TextOut(page,margin+2*colsize,height-80- rowheight*2,"Elevation");
-			HPDF_Page_TextOut(page,margin+3*colsize,height-80- rowheight*2,"Velocity");
-			HPDF_Page_TextOut(page,margin+4*colsize,height-80- rowheight*2,"Energy");
-			HPDF_Page_TextOut(page,margin+5*colsize,height-80- rowheight*2,"Wind Drift");
-			HPDF_Page_TextOut(page,margin+6*colsize,height-80- rowheight*2,"Windage");
-			HPDF_Page_TextOut(page,margin+7*colsize,height-80- rowheight*2,"Time");
-			
-			HPDF_Page_TextOut (page,margin+0*colsize, height - 80 - rowheight*3, "(yards)");
-			HPDF_Page_TextOut(page,margin+1*colsize,height-80- rowheight*3, "(inches)");
-			HPDF_Page_TextOut(page,margin+2*colsize,height-80- rowheight*3,"(MOA)");
-			HPDF_Page_TextOut(page,margin+3*colsize,height-80- rowheight*3,"(ft/s)");
-			HPDF_Page_TextOut(page,margin+4*colsize,height-80- rowheight*3,"(ft-lb)");
-			HPDF_Page_TextOut(page,margin+5*colsize,height-80- rowheight*3,"(inches)");
-			HPDF_Page_TextOut(page,margin+6*colsize,height-80- rowheight*3,"(MOA)");
-			HPDF_Page_TextOut(page,margin+7*colsize,height-80- rowheight*3,"(seconds)");
-	
+                	// headers
+                	row=0;
+                	for (int hline=0; hline < T->GetHeaderLines(); hline++) {
+                	    int col;
+                            for (col=0; col < T->GetColumns(); col++) {
+                                HPDF_Page_TextOut(page,margin+col*colsize, height-80-rowheight*row, T->GetHeader(col,hline));
+                            }
+                            row++;
+                        }
 			HPDF_Page_EndText (page);
 
 			HPDF_Page_SetFontAndSize (page, def_font, 8);
-			row=5;
+			row++;
 		}
 	
 
@@ -817,7 +788,3 @@
 
 
 }
-
-
-		  
-
diff -x Makefile.in -x autom4te.cache -x configure -x aclocal.m4 -urN gebc-1.07/RangeWindow.h gebc-1.07-mike/RangeWindow.h
--- gebc-1.07/RangeWindow.h	2008-03-01 04:47:22.000000000 +0900
+++ gebc-1.07-mike/RangeWindow.h	2010-11-01 00:06:49.935693936 +0800
@@ -22,6 +22,7 @@
       ~RangeWindow();
 	  int* colwidths;
 	  int min,max,step,maxvalid;
+	  int targetsize;
 	  Fl_Menu_Bar* menu;
 	  Fl_Browser* tbl;
 	  GBCSolution* Sln;
@@ -62,10 +63,16 @@
 	static void cb_ExportOO(Fl_Widget*, void*);
 	static void cb_ExportPDF(Fl_Widget*, void*);
 	static void cb_Close(Fl_Widget*, void*);
-		  
-		  
 	
-	void GenTable(void);
+	int   GetColumns(void);
+	int   GetHeaderLines(void);
+	const char *GetHeader(int col, int row);
+	int   GetPrefaceLines();
+	void  GetPreface(int l, char *str);
+	
+	int   GetData(int col, int range, char *buf);
+	char *GetData(int col, int range);
+	void  GenTable(void);
 
 };
 
diff -x Makefile.in -x autom4te.cache -x configure -x aclocal.m4 -urN gebc-1.07/TargetWindow.cpp gebc-1.07-mike/TargetWindow.cpp
--- gebc-1.07/TargetWindow.cpp	1970-01-01 08:00:00.000000000 +0800
+++ gebc-1.07-mike/TargetWindow.cpp	2011-01-29 22:08:00.567065252 +0800
@@ -0,0 +1,723 @@
+#include "TargetWindow.h"
+
+#define PT_PATH		0
+
+TargetWindow::TargetWindow(int w, int h, GBCSolution* Gsln, GBCSolution* GMEM1, GBCSolution* GMEM2, GBCSolution* GMEM3) : Fl_Window(w,h,"Solution Visualization Tools"){
+	
+	// Store a pointer to the calling solution.
+	gsln=Gsln;
+	mem1=GMEM1;
+	mem2=GMEM2;
+	mem3=GMEM3;
+	
+	x_click=0;
+	y_click=0;
+	
+	begin();
+	this->size_range(0,0,1600,1600);
+	
+	// Put a simple menu, for saving or closing the window.
+	menu = new Fl_Menu_Bar(0,0,w,25,"MENU");
+
+	Fl_Menu_Item items[]= {
+	    {"&File",0,0,0,FL_SUBMENU},
+		 {"Save as..",0,0,0,FL_SUBMENU | FL_MENU_INACTIVE},
+		    {"PNG (.png)",0,(Fl_Callback*)cb_nothing,this,0},
+			{"JPEG (.jpg)",0,(Fl_Callback*)cb_nothing,this,0},
+			{"Bitmap (.bmp)",0,(Fl_Callback*)cb_nothing,this,0},
+			{"Adobe PDF (.pdf)",0,(Fl_Callback*)cb_nothing,this,0},
+			{0},
+		  {"&Close",0,(Fl_Callback*)cb_Close,this,0},
+		  {0},			
+		{0}
+	};
+	
+	menu->copy(items);
+	menu->down_box(FL_NO_BOX);
+
+	// Put in a range slider for selecting the chart's range.	
+	sl_x = new Fl_Value_Slider(10,30,270,30,"Range (yds)");
+	sl_x->align(FL_ALIGN_RIGHT);
+	sl_x->value(200);
+	sl_x->minimum(30);
+	sl_x->maximum(gsln->MaxRows());
+	sl_x->type(FL_HOR_NICE_SLIDER);
+	sl_x->callback(cb_slUpdate,this);
+	sl_x->precision(0);
+	sl_x->step(10);
+
+	btPerspective=new Fl_Check_Button(380,35,20,20,"Perspective");
+	btPerspective->value(1);
+	btPerspective->callback(cb_Perspective,this);
+	btPerspective->tooltip("Apply perspective to bullet path");
+	
+	Fl_Menu_Item guideitems[]={
+	   {"None",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"1,5 MIL",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"1-5 MIL",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"1-10 MIL",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"1-5,10 MIL",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"2,10 MOA",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"2,4,6,8,10 MOA",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"2-20 MOA",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"2-10,20 MOA",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"1-5 Degrees",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {"5,10,15 Degree",0,(Fl_Callback*)cb_Guides, this, 0},
+	   {0}
+	   };
+	cScopeGuides = new Fl_Choice(330,65,150,30,"Scope Guides");
+	cScopeGuides->copy(guideitems);
+	cScopeGuides->value(1);
+	
+	btMem1 = new Fl_Check_Button(490,30,20,20,"Memory 1");
+	btMem2 = new Fl_Check_Button(490,50,20,20,"Memory 2");
+	btMem3 = new Fl_Check_Button(490,70,20,20,"Memory 3");
+	btMem1->align(FL_ALIGN_RIGHT);
+	btMem2->align(FL_ALIGN_RIGHT);
+	btMem3->align(FL_ALIGN_RIGHT);
+	btMem1->labelcolor(FL_RED);
+	btMem2->labelcolor(FL_DARK_GREEN);
+	btMem3->labelcolor(FL_BLACK);
+	btMem1->callback(cb_Mem1,this);
+	btMem2->callback(cb_Mem2,this);
+	btMem3->callback(cb_Mem2,this);
+	
+	if (mem1==NULL) btMem1->deactivate();
+	if (mem2==NULL) btMem2->deactivate();
+	if (mem3==NULL) btMem3->deactivate();
+	
+	if (mem1!=NULL) btMem1->tooltip(mem1->Name());
+	if (mem2!=NULL) btMem2->tooltip(mem2->Name());
+	if (mem3!=NULL) btMem3->tooltip(mem3->Name());
+	
+#define TARGET_COUNT 15
+	Fl_Menu_Item plottypeitems[TARGET_COUNT+1]={
+	   {"1/2\" Rings",0,(Fl_Callback*)cb_TargetType, this, 0},
+	   {"1\" Rings",0,(Fl_Callback*)cb_TargetType, this, 0},
+	   {"2\" Rings",0,(Fl_Callback*)cb_TargetType, this, 0},
+	   
+	   {"ISSF 10m Air Pistol",0,(Fl_Callback*)cb_TargetType, this, 0},
+	   {"ISSF 10m Air Rifle",0,(Fl_Callback*)cb_TargetType, this, 0},
+	   {"ISSF 25m Rapid Fire Pistol",0,(Fl_Callback*)cb_TargetType, this, 0},
+	   {"ISSF 25m Pistol",0,(Fl_Callback*)cb_TargetType, this, 0},
+	   {"ISSF 50m Pistol",0,(Fl_Callback*)cb_TargetType, this, 0},
+
+	   {"ISSF 50m Rifle",0,(Fl_Callback*)cb_TargetType, this, 0},
+	   {"ISSF 300m Rifle",0,(Fl_Callback*)cb_TargetType, this, 0},
+	   
+	   {"NRA 200 yard reduced for 100yd",0,(Fl_Callback*)cb_TargetType, this, 0},
+	   {"NRA 200 yard",0,(Fl_Callback*)cb_TargetType, this, 0},
+	   {"NRA 300 yard",0,(Fl_Callback*)cb_TargetType, this, 0},
+	   {"NRA 600 yard",0,(Fl_Callback*)cb_TargetType, this, 0},
+	   {"NRA 800 yard+",0,(Fl_Callback*)cb_TargetType, this, 0},
+	   {0}
+	   };
+	cTargetType = new Fl_Choice(60,65,160,30,"Target");
+	cTargetType->copy(plottypeitems);
+	cTargetType->value(1);
+	
+	end();
+	show();
+	
+	
+}
+
+TargetWindow::~TargetWindow(void){
+
+	delete menu;
+	delete sl_x;
+	delete btMem1;
+	delete btMem2;
+	delete btMem3;
+	delete cScopeGuides;
+	delete cTargetType;
+	
+
+}
+
+
+void TargetWindow::draw(void){
+	
+	// Let the window draw itself first.
+	Fl_Window::draw();
+	
+	PlotPath(PT_PATH);
+}
+
+int TargetWindow::handle(int evt){
+
+	if (evt==FL_PUSH && Fl::event_button1()){
+		x_click=Fl::event_x();
+		y_click=Fl::event_y();
+		this->redraw();
+			
+	}
+	
+
+	
+	return Fl_Window::handle(evt);
+
+}
+
+
+/* 
+    PlotMem()
+    
+    Plot the requested data from a given GBCSolution (the current solution or a memory)
+    
+    mode = 0: Path, 1: Energy, 2: Velocity, 3: Wind Drift
+
+*/
+
+void TargetWindow::PlotMem(GBCSolution* mem, int mode){
+
+  double x1,x2;
+  double y1,y2;
+  int px1, px2, py1,py2;
+  int range;
+  
+  double t_range=sl_x->value();
+  int perspective=btPerspective->value()==1;
+  int start = perspective ? 20 : 0;
+  
+  x1=mem->GetWindage(start);
+  y1=mem->GetPath(start);
+  
+  // apply perspective
+  if (perspective) {
+     y1*=t_range / (double)(start+1);
+     x1*=t_range / (double)(start+1);
+     }
+
+  int m=this->gsln->MaxRows();
+
+  for (int n=start+1;n<=t_range && n<m ;n++){
+	x2=mem->GetWindage(n);
+	y2=mem->GetPath(n);
+
+	// apply perspective
+	if (perspective && n<t_range) {
+	   y2*=t_range / (double)(n+1);
+	   x2*=t_range / (double)(n+1);
+	   }
+	   
+	// Translate the x,y values into scaled pixels.
+	px1=(int)(x0+x_scale*(double)x1);
+	px2=(int)(x0+x_scale*(double)x2);
+	
+	py1=(int)((y0)-(double)y_scale*(double)y1);
+	py2=(int)((y0)-(double)y_scale*(double)y2);
+
+	if (n>50) {
+	   if (py2>=ymax) break;
+	   if (px2>=xmax) break;
+	   }
+	
+	// Plot the points.
+	if (px1>xmin && px1<xmax && py1<ymax && py1>ymin)
+		fl_line(px1,py1,px2,py2);
+	
+	x1=x2;
+	y1=y2;
+	}
+
+   // draw a "bullet hole" at the impact point
+   //fl_color(FL_YELLOW);
+   double r=0.300/2; // should use half caliber here
+   double r2;
+   fl_pie(px2 - (r*x_scale), py2-(r*y_scale), r*2*x_scale, r*2*y_scale, 0, 360);
+
+   // and a 1-MOA ring (predicted impact variance)
+   // plus 0.1 MOA for every 100 yds over 100 yds (rough spin drift allowance)
+   r=(1.0 * t_range / 100.0)/2;
+   r2=r;
+   if (t_range > 100) r2 += (t_range - 100)/1000;
+   
+   fl_color(fl_gray_ramp(FL_NUM_GRAY * 2 / 4));
+   fl_arc(px2 - (r2*x_scale), py2-(r*y_scale), r2*2*x_scale, r*2*y_scale, 0, 360);
+}
+
+
+/*
+   SetupPlot()
+   
+   Calculate some common parameters for the plots
+   This code was common to all plots (Path, Energy, Velocity) and was consolidated here
+   
+   Requires x_range and y_range to be set before calling
+*/
+
+int get_ticks(int range) {
+	if (range < 100) return 10;
+	if (range < 200) return 20;
+	if (range < 400) return 50;
+	if (range < 800) return 100;
+	if (range < 1600) return 200;
+	if (range < 3200) return 500;
+	if (range < 6400) return 1000;
+	if (range < 12800) return 2000;
+	if (range < 25600) return 4000;
+	if (range < 51200) return 8000;
+	if (range < 102400) return 16000;
+	if (range < 204800) return 32000;
+	return 64000;
+}
+
+void TargetWindow::SetupPlot(void){
+
+	int w = this->w();
+	int h = this->h();
+	
+	xmin = 5;
+	xmax = w-5;
+	ymin = 100;
+	ymax = h-5;
+
+	x_scale = (double)(xmax-xmin) / (double)x_range;
+	y_scale = (double)(ymax-ymin) / (double)y_range;
+	
+	x_ticks=get_ticks(x_range);
+	y_ticks=get_ticks(y_range);
+}
+
+
+/*
+   DrawPlotBackground()
+   
+   Draw the graph background, axis, scale etc
+   Code was common to all plots and has been consolidated here
+   
+   Requires SetupPlot to have been called and y0 set first
+*/
+
+void TargetWindow::DrawPlotBackground(int mode, const char *ylabel){
+
+	// Draw the x-axis.
+	fl_color(FL_BLACK);
+	fl_line_style(FL_SOLID,2);
+	fl_line(xmin,y0,xmax,y0);
+	
+	// Draw the y-axis
+	fl_line(x0,ymin,x0,ymax);
+
+	double px;
+	fl_color(FL_BLACK);
+	fl_line_style(FL_SOLID,1);
+	char txt[64];
+	int r=0;
+	double txtw=0;
+
+	int tick_top=ymax;
+	if (mode != PT_PATH) tick_top=y0;
+
+	// Draw X gridlines every x_ticks yds and label them.
+	if (xmin<0) {
+	   for (px=x0;px>=xmin;px-=((double)x_ticks*x_scale)){
+		//fl_line((int)px,y_bottom,(int)px,y_top);
+		fl_line_style(FL_DOT,1);
+		fl_line((int)px,(int)ymin,(int)px,tick_top);
+		sprintf(txt,"%d",r*x_ticks);
+		if (r%2==0 && r>0) {
+			txtw=fl_width(txt);
+			fl_line_style(FL_SOLID,1);
+			fl_line((int)px,y0,(int)px,y0+8);
+			fl_draw(txt,(int)((int)px-(txtw/2)),y0+10+fl_height());
+		}
+		r++;
+	   }
+	}
+
+	// Draw X gridlines every x_ticks yds and label them.
+	for (px=x0;px<=xmax;px+=((double)x_ticks*x_scale)){
+		//fl_line((int)px,y_bottom,(int)px,y_top);
+		fl_line_style(FL_DOT,1);
+		fl_line((int)px,(int)ymin,(int)px,tick_top);
+		sprintf(txt,"%d",r*x_ticks);
+		if (r%2==0 && r>0) {
+			txtw=fl_width(txt);
+			fl_line_style(FL_SOLID,1);
+			fl_line((int)px,y0,(int)px,y0+8);
+			fl_draw(txt,(int)((int)px-(txtw/2)),y0+10+fl_height());
+		}
+		r++;
+	}
+	
+	// Draw Y hashmarks every 1 y_tick going up.
+	double py;
+	r=0;
+	for (py=y0;py>=ymin;py-=((double)y_ticks*y_scale)){
+		if (r>0){
+			fl_line(xmin,(int)py,xmax,(int)py);
+			sprintf(txt,"+%d%s",r*y_ticks, ylabel);
+			fl_draw(txt,xmin+10,(int)(py+fl_height()/2));
+		}
+		r++;
+	}
+	
+	// Draw Y hashmarks every 1 y_tick going down
+	if (mode==PT_PATH) {
+	   r=0;
+	   for (py=y0;py<=ymax;py+=((double)y_ticks*y_scale)){
+		if (r>0){
+			fl_line(xmin,(int)py,xmax,(int)py);
+			sprintf(txt,"-%d%s",r*y_ticks, ylabel);
+			if (py+fl_height()/2<ymax)	fl_draw(txt,xmin+10,(int)(py+fl_height()/2));
+		}
+		r++;
+	   }
+	}
+
+}
+
+
+void TargetWindow::DrawPlotData(int mode){
+
+	fl_color(FL_BLUE);
+	fl_line_style(FL_SOLID,1);
+	PlotMem(this->gsln, mode);
+	
+	if (btMem1->value()==1){
+		fl_color(FL_RED);
+		fl_line_style(FL_SOLID,1);
+		PlotMem(mem1, mode);
+		}
+	if (btMem2->value()==1){
+		fl_color(FL_GREEN);
+		fl_line_style(FL_SOLID,1);
+		PlotMem(mem2, mode);
+		}
+	if (btMem3->value()==1){
+		fl_color(FL_BLACK);
+		fl_line_style(FL_SOLID,1);
+		PlotMem(mem3, mode);
+		}
+	
+	if (x_click>xmin && x_click<xmax && y_click>ymin && y_click<ymax){
+		// If the user clicks, show the coordinates they clicked on.
+		double click_label_x= ((x_click)-x0)/x_scale;
+		double click_label_y= (y0-y_click)/y_scale;
+		char lbl_point[20];
+		sprintf(lbl_point,"(%.2f,%.2f)",click_label_x, click_label_y);
+		fl_color(FL_RED);
+		fl_draw(lbl_point,x_click+5, y_click-5);
+		fl_rectf(x_click-2, y_click-2,4,4);
+	}
+
+	// Draw the frame around it last to make it all pretty.
+	fl_frame("aaaa",5,100,w()-10,h()-105);
+
+}
+
+
+void TargetWindow::PlotPath(int ptype){
+
+	// We need to find the max and min y-values to determine our y scale and y-ticks
+	double _miny=0;
+	double _maxy=0;
+	double _minx=0;
+	double _maxx=0;
+	double minsize=20;
+	
+	switch (cTargetType->value()) {
+	    case 0: minsize=6;
+	            break;
+	    case 1: minsize=12;
+	            break;
+	    case 2: minsize=12;
+	    	    break;
+	    case 3: minsize=5;
+		    break;
+	    case 4: minsize=1.5;
+	    	    break;
+	    case 5:
+	    case 6:
+	    case 7: minsize=10;
+	            break;
+	    case 8: minsize=5;
+	    	    break;
+	    }
+
+
+	for (int e=0;e<sl_x->value();e++){
+	    double v=gsln->GetPath(e);
+	    if (v > _maxy) _maxy=v;
+	    if (v < _miny) _miny=v;
+	    v=gsln->GetWindage(e);
+	    if (v > _maxx) _maxx=v;
+	    if (v < _minx) _minx=v;
+	}
+
+	if (_minx > -minsize) _minx=-minsize;
+	else _minx *= 1.05;
+	if (_maxx <  minsize) _maxx=minsize;
+	else _maxx *= 1.05;
+	x_range= _maxx - _minx;
+	
+	_miny*=1.1;
+	if (_miny > -minsize) _miny=-minsize;
+	else _miny*=1.05;
+	if (_maxy < minsize) _maxy=minsize;
+	else _maxy*=1.05;
+	
+	if (_maxy < fabs(_miny)/3) _maxy = fabs(_miny)/3;
+	else if (fabs(_miny) < (_maxy/3)) _miny = -_maxy/3;
+	
+	y_range = _maxy - _miny;
+
+	// keep a fixed aspect ratio, and keep the target roughly central
+	if (y_range < x_range) y_range=x_range;
+	if (x_range < y_range) x_range=y_range;
+
+	t_range = (int)sl_x->value();
+	
+	SetupPlot();
+	y0 = ymax + (_miny * y_scale);
+	x0 = xmin - (_minx * x_scale);
+
+	// Now do our custom drawing.
+	fl_draw_box(FL_FLAT_BOX,xmin,ymin,w()-10,h()-ymin-5,FL_WHITE);
+
+	fl_clip(5,100,w()-10,h()-105);
+	fl_line_style(FL_SOLID,1);
+
+	// Draw the score circles at 1 inch intervals
+	double r, aimring, *rings;
+	int i, score, aimring_drawn=0; 
+	char txt[10];
+	#define mm(x) (x/25.4)
+	double aimrings[TARGET_COUNT]=
+	        { 3, 6, 12,						// 1/2, 1, 2"
+	          mm(59.5), mm(30.5), mm(500), mm(200), mm(200), 	// ISSF Pistol
+	          mm(112.4), mm(600), 					// ISSF Rifle
+	          6.35, 13, 19, 36, 44					// NRA
+	        };
+	double rings_data[TARGET_COUNT][13] = {
+		{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0 },		// 1/2" rings
+		{ 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 0 },		// 1" rings
+		{ 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 0 },	// 2" rings
+
+		// ISSF 10m Air Pistol - 11.5mm 10 ring, increasing by 16mm
+		{ mm(6.5), mm(11.5), mm(27.5), mm(43.5), mm(59.5), mm(75.5), mm(91.5), mm(107.5), mm(123.5), mm(139.5), mm(155), 0 },
+		// ISSF 10m Air Rifle
+		{ -0.01, mm(0.5), mm(5.5), mm(10.5), mm(15.5), mm(20.5), mm(25.5), mm(30.5), mm(35.5), mm(40.5), mm(45.5), 0 },
+		// ISSF 25m Rapid Pistol - 100mm 10 ring, increasing by 100mm
+		{ mm(50), mm(100), mm(180), mm(260), mm(340), mm(420), mm(500), 0 },
+		// ISSF 25m Precision Pistol - 50mm 10 ring, increasing by 50mm
+		{ mm(25), mm(50), mm(100), mm(150), mm(200), mm(250), mm(300), mm(350), mm(400), mm(450), mm(500), 0 },
+		// ISSF 50m Precision Pistol - 50mm 10 ring, increasing by 50mm
+		{ mm(25), mm(50), mm(100), mm(150), mm(200), mm(250), mm(300), mm(350), mm(400), mm(450), mm(500), 0 },
+
+		// ISSF 50m Rifle
+		{ mm(5.2), mm(10.4), mm(26.4), mm(42.4), mm(58.4), mm(74.4), mm(90.4), mm(106.4), mm(122.4), mm(138.4), mm(154.4), 0 },
+		// ISSF 300m Rifle
+		{ mm(50), mm(100), mm(200), mm(300), mm(400), mm(500), mm(600), mm(700), mm(800), mm(900), mm(1000), 0 },
+		
+		{ 1.35, 3.35, 6.35, 9.35, 12.35, 15.35, 18.35, 0 },	// NRA 100 yard reduction of 200 yard
+		{ 3, 7, 13, 19, 25, 31, 37, 0 },			// NRA 200 yard
+		{ 3, 7, 13, 19, 25, 31, 37, 0 },			// NRA 300 yard
+		{ 6, 12, 18, 24, 36, 48, 60, 0 },			// NRA 600 yard
+		{ 10, 20, 30, 44, 60, 72, 0 },				// NRA 800 yard+
+		};
+		
+	aimring = aimrings[cTargetType->value()];
+	rings   = rings_data[cTargetType->value()];
+	    
+	score=11;
+	i=0;
+	while (i<=10 && rings[i]!=0) { 
+	   i++;
+	   score--;
+	   }
+	   
+	while (i > 0) {
+	    i--;
+	    score++;
+	    
+	    if (rings[i] < 0) continue;
+	    r=rings[i]/2;
+	    
+	    if (rings[i] <= aimring && !aimring_drawn) {
+	       fl_color(FL_GRAY);
+	       double ar=aimring/2;
+	       fl_pie(x0 - (ar*x_scale), y0-(ar*y_scale), ar*2*x_scale, ar*2*y_scale, 0, 360);
+	       aimring_drawn=1;
+	       }
+	       
+	    if (i==0 && 1) {
+	       fl_color(FL_RED);
+	       fl_pie(x0 - (r*x_scale), y0-(r*y_scale), r*2*x_scale, r*2*y_scale, 0, 360);
+	       }
+	    else {
+	       //fl_color(rings[i] > aimring ? FL_BLACK : FL_WHITE);
+	       fl_color(FL_BLACK);
+	       fl_arc(x0 - (r*x_scale), y0-(r*y_scale), r*2*x_scale, r*2*y_scale, 0, 360);
+	       }	       
+	    
+	    //fl_color(rings[i] > aimring ? FL_BLACK : FL_WHITE);
+	    fl_color(FL_BLACK);
+	    
+	    // draw the score centred in the ring
+	    if (score>9 && r < 0.9) {
+	       // don't bother to draw score as ring is too small
+	       }
+	    else if (score==11 || i==0) {
+	       fl_draw("X", x0 + 1, y0 - 5);
+	       }
+	    else {
+	       sprintf(txt, "%d", score);
+	       double w = (r - (rings[i-1]/2)) / 2;
+	       fl_draw(txt, x0 + ((r - w)*x_scale) - (fl_width(txt)/2) - 1, y0 - 5);
+	       }
+	    }
+	fl_pop_clip();
+
+	DrawPlotBackground(ptype, "\"");
+
+	// draw +/- 1 and 5 MOA or MIL lines
+	if (cScopeGuides->value() > 0) {
+	   int sgmode=cScopeGuides->value();
+	   double pix_inset=50;
+
+	   // one MIL - not quite equal to one real milliradian
+	   long double oneunit = 3.1415 / 3200;
+
+	   if (sgmode >= 5)
+	        oneunit=oneunit / 3.438; // use one moa instead
+	   if (sgmode >= 9)
+	        oneunit=0.0174532925; // use one degree
+	   
+	   double range_inset=pix_inset/x_scale;
+	   double radius, dotradius;
+	   int start, stop, step, step2, g, dotwidth, dotheight;
+	   char txt[10];
+	   
+	   step2=0;
+	   switch (sgmode) {
+	      case 1: start=1; stop=5;  step=4; break;		 // 1,5 MIL
+	      case 2: start=1; stop=5;  step=1; break;		 // 1-5 MIL
+	      case 3: start=1; stop=10; step=1; break;		 // 1-10 MIL
+	      case 4: start=1; stop=5;  step=1; step2=5; break;	 // 1-5,10 MIL
+	      case 5: start=2; stop=10; step=8; break;		 // 2,10 MOA
+	      case 6: start=2; stop=10; step=2; break;		 // 2,4,6,8,10 MOA
+	      case 7: start=2; stop=20; step=2; break;		 // 2-20 MOA
+	      case 8: start=2; stop=10; step=2; step2=10; break; // 2,4,6,8,10,20 MOA
+	      case 9:  start=1; stop=5; step=1; break;		 // 1-10 Degrees
+	      case 10: start=5; stop=15; step=5; break;		 // 5,10,15 Degrees
+	      
+	      default: start=1; stop=1; step=1; break;
+	      }
+
+	   fl_clip(5,100,w()-10,h()-105);
+	   fl_line_style(FL_SOLID,2);
+	   fl_color(FL_BLACK);
+	   
+	   dotradius= 0.25/2;
+	   dotwidth = tanf(oneunit * dotradius) * t_range * 36.0 * x_scale;
+	   dotheight= tanf(oneunit * dotradius) * t_range * 36.0 * y_scale;
+	   
+	   for (g=start; g<=stop; g+=step) {
+	       radius = tanf(oneunit*g) * t_range * 36.0;
+	       
+	       if (radius <= -_miny || radius <= x_range/2) {
+	          //fl_color(radius > aimring ? FL_BLACK : FL_WHITE);
+	          fl_line(x0-(radius*x_scale), y0+dotheight, x0-(radius*x_scale), y0-dotheight);
+	          fl_line(x0+(radius*x_scale), y0+dotheight, x0+(radius*x_scale), y0-dotheight);
+	          fl_line(x0-dotwidth, y0-(radius*y_scale), x0+dotwidth, y0-(radius*y_scale));
+	          fl_line(x0-dotwidth, y0+(radius*y_scale), x0+dotwidth, y0+(radius*y_scale));
+	          if (g==start) {
+	             if (sgmode>=9) sprintf(txt, "-%d Deg", g);
+	             else if (sgmode>=5) sprintf(txt, "-%d MOA", g);
+	             else sprintf(txt, "-%d MIL", g);
+	             }
+	          else sprintf(txt, "-%d", g);
+	          fl_draw(txt, x0+dotwidth+2, y0+(radius*y_scale) + 3);
+	          }
+	       }
+	   if (step2 > 0) {
+	       g+=step2-step;
+	       radius =tanf(oneunit*g) * t_range * 36.0;
+
+	       if (radius <= -_miny || radius <= x_range/2) {
+	          //fl_color(radius > aimring ? FL_BLACK : FL_WHITE);
+	          fl_line(x0-(radius*x_scale), y0+dotheight, x0-(radius*x_scale), y0-dotheight);
+	          fl_line(x0+(radius*x_scale), y0+dotheight, x0+(radius*x_scale), y0-dotheight);
+	          fl_line(x0-dotheight, y0-(radius*y_scale), x0+dotheight, y0-(radius*y_scale));
+	          fl_line(x0-dotheight, y0+(radius*y_scale), x0+dotheight, y0+(radius*y_scale));
+	          sprintf(txt, "+%d", g);
+	          fl_draw(txt, x0+dotwidth+2, y0+(radius*y_scale)+3);
+	          }
+	       }
+
+	   fl_pop_clip();
+	   }
+	   
+	DrawPlotData(ptype);
+
+	return;
+}
+
+
+void TargetWindow::cb_btPlot(Fl_Widget* o, void* v){
+	TargetWindow* T = (TargetWindow*)v;
+	
+	T->damage(255);
+	T->draw();
+
+
+}
+
+void TargetWindow::cb_nothing(Fl_Widget* o, void* v){
+
+	;
+}
+
+void TargetWindow::cb_Close(Fl_Widget* o, void* v){
+	TargetWindow* T = (TargetWindow*)v;
+	T->~TargetWindow();
+}
+
+void TargetWindow::cb_slUpdate(Fl_Widget* o, void* v){
+
+	TargetWindow* T = (TargetWindow*)v;
+	T->damage(255);
+	T->draw();
+}
+
+void TargetWindow::cb_Mem1(Fl_Widget* o, void* v){
+
+	TargetWindow* T = (TargetWindow*)v;
+	T->damage(255);
+	T->draw();
+
+}
+
+
+void TargetWindow::cb_Mem2(Fl_Widget* o, void* v){
+
+	TargetWindow* T = (TargetWindow*)v;
+	T->redraw();
+
+}
+
+void TargetWindow::cb_Guides(Fl_Widget* o, void* v){
+
+	TargetWindow* T = (TargetWindow*)v;
+	T->redraw();
+
+}
+
+void TargetWindow::cb_TargetType(Fl_Widget* o, void* v){
+
+	TargetWindow* T = (TargetWindow*)v;
+	T->redraw();
+
+}
+
+void TargetWindow::cb_Perspective(Fl_Widget* o, void* v){
+
+	TargetWindow* T = (TargetWindow*)v;
+	T->redraw();
+
+}
+
+
diff -x Makefile.in -x autom4te.cache -x configure -x aclocal.m4 -urN gebc-1.07/TargetWindow.h gebc-1.07-mike/TargetWindow.h
--- gebc-1.07/TargetWindow.h	1970-01-01 08:00:00.000000000 +0800
+++ gebc-1.07-mike/TargetWindow.h	2011-01-28 07:26:00.421064431 +0800
@@ -0,0 +1,80 @@
+#ifndef __TARGETWINDOW
+#define __TARGETWINDOW
+
+#include <FL/Fl.H>
+#include <FL/Fl_Window.H>
+#include <FL/Fl_Round_Button.H>
+#include <FL/Fl_Check_Button.H>
+#include <FL/Fl_Value_Slider.H>
+#include <FL/fl_draw.h>
+#include <FL/Fl_Menu_Bar.H>
+#include <FL/Fl_Menu_Item.H>
+#include <FL/Fl_Choice.H>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+
+#include "GBCSolution.h"
+
+class TargetWindow : public Fl_Window {
+	public:
+	TargetWindow(int, int, GBCSolution*, GBCSolution*, GBCSolution*, GBCSolution*);
+	~TargetWindow(void);
+	GBCSolution* gsln;
+	GBCSolution* mem1;
+	GBCSolution* mem2;
+	GBCSolution* mem3;
+	
+
+	
+	private:
+	virtual void draw(void);
+	int cwidth;
+	int cheight;
+	int x_ticks;
+	int y_ticks;
+	
+	int xmin, ymin, xmax, ymax;
+	int y0, x0;
+	int t_range;
+	double x_range, y_range;
+	double x_scale, y_scale;
+	
+	void PlotMem(GBCSolution* mem, int mode);
+	void SetupPlot(void);
+	void DrawPlotBackground(int mode, const char *ylabel);
+	void DrawPlotData(int mode);
+	void PlotPath(int ptype);
+	
+	int x_click;
+	int y_click;
+	
+	Fl_Check_Button* btMem1;
+	Fl_Check_Button* btMem2;
+	Fl_Check_Button* btMem3;
+	Fl_Check_Button* btPerspective;
+	
+	Fl_Value_Slider* sl_x;
+	
+	Fl_Choice* cScopeGuides;
+	Fl_Choice* cTargetType;
+	
+	Fl_Menu_Bar* menu;
+	
+	virtual int handle(int);
+	static void cb_nothing(Fl_Widget* o, void* v);
+	static void cb_Close(Fl_Widget* o, void* v);
+	static void cb_btPlot(Fl_Widget* o, void* v);
+	static void cb_slUpdate(Fl_Widget* o, void* v);
+	static void cb_Mem1(Fl_Widget* o, void* v);
+	static void cb_Mem2(Fl_Widget* o, void* v);
+	static void cb_Mem3(Fl_Widget* o, void* v);
+	static void cb_Guides(Fl_Widget* o, void* v);
+	static void cb_TargetType(Fl_Widget* o, void* v);
+	static void cb_Perspective(Fl_Widget* o, void* v);
+	
+
+};
+
+#endif
diff -x Makefile.in -x autom4te.cache -x configure -x aclocal.m4 -urN gebc-1.07/lib/ballistics/ballistics.cpp gebc-1.07-mike/lib/ballistics/ballistics.cpp
--- gebc-1.07/lib/ballistics/ballistics.cpp	2008-03-01 04:54:11.000000000 +0900
+++ gebc-1.07-mike/lib/ballistics/ballistics.cpp	2011-01-23 00:01:08.142065479 +0800
@@ -260,6 +260,14 @@
 	else return 0;
 }
 
+double GetDrop(double* sln, int yardage){
+	double size=sln[__BCOMP_MAXRANGE__*10+1];
+	if (yardage<size){
+		return sln[10*yardage+9];
+	}
+	else return 0;
+}
+
 
 
 
@@ -415,7 +423,7 @@
 			ptr[10*n+6]=v;								// Velocity (combined)
 			ptr[10*n+7]=vx;							// Velocity (x)
 			ptr[10*n+8]=vy;							// Velocity (y)
-			ptr[10*n+9]=0;								// Reserved
+			ptr[10*n+9]=(y - ((x*tan(DegtoRad(ZAngle))) - (SightHeight/12)))*12;	// Drop in inches
 			n++;	
 		}	
 		
diff -x Makefile.in -x autom4te.cache -x configure -x aclocal.m4 -urN gebc-1.07/lib/ballistics/ballistics.h gebc-1.07-mike/lib/ballistics/ballistics.h
--- gebc-1.07/lib/ballistics/ballistics.h	2008-03-01 04:54:11.000000000 +0900
+++ gebc-1.07-mike/lib/ballistics/ballistics.h	2011-01-29 13:48:21.117066348 +0800
@@ -91,6 +91,7 @@
 double GetVelocity(double* sln, int yardage); // Returns the projectile's total velocity (Vector product of Vx and Vy)
 double GetVx(double* sln, int yardage); // Returns the velocity of the projectile in the bore direction.
 double GetVy(double* sln, int yardage); // Returns the velocity of the projectile perpendicular to the bore direction.
+double GetDrop(double* sln, int yardage); // Returns the drop in inches below the bore direction.
 
 // For very steep shooting angles, Vx can actually become what you would think of as Vy relative to the ground, 
 // because Vx is referencing the bore's axis.  All computations are carried out relative to the bore's axis, and
